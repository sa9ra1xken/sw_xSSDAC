# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 289 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 37 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\limits.h" 1 3



# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\newlib.h" 1 3
# 4 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\limits.h" 2 3
# 131 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\limits.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\limits.h" 1 3
# 131 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\limits.h" 2 3
# 38 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 1 3
# 29 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/_ansi.h" 1 3
# 16 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/_ansi.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/config.h" 1 3



# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/ieeefp.h" 1 3
# 5 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/config.h" 2 3
# 16 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/_ansi.h" 2 3
# 29 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 2 3





# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 1 3
# 66 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 3
typedef unsigned int size_t;
# 34 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 2 3



# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stdarg.h" 1 3
# 31 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stdarg.h" 3
typedef __builtin_va_list va_list;
# 51 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 37 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 2 3








# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/reent.h" 1 3
# 14 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/reent.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/_types.h" 1 3
# 12 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/_types.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_types.h" 1 3






# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_default_types.h" 1 3
# 26 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 8 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/_types.h" 2 3
# 13 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/_types.h" 2 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/lock.h" 1 3







typedef int _LOCK_SIMPLE_T;

typedef struct {

  unsigned _counter;


  unsigned _owner;
} _LOCK_FAIR_T;

typedef struct {
  int _owner;
  int _count;
} _LOCK_RECURSIVE_T;
# 30 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/lock.h" 3
void __lock_simple_init(volatile _LOCK_SIMPLE_T *);
void __lock_simple_close(volatile _LOCK_SIMPLE_T *);
void __lock_simple_acquire(volatile _LOCK_SIMPLE_T *);
int __lock_simple_try_acquire(volatile _LOCK_SIMPLE_T *);
void __lock_simple_release(volatile _LOCK_SIMPLE_T *);

void __lock_fair_init(volatile _LOCK_FAIR_T *);
void __lock_fair_close(volatile _LOCK_FAIR_T *);
void __lock_fair_acquire(volatile _LOCK_FAIR_T *);
int __lock_fair_try_acquire(volatile _LOCK_FAIR_T *);
void __lock_fair_release(volatile _LOCK_FAIR_T *);

void __lock_recursive_init(volatile _LOCK_RECURSIVE_T *);
void __lock_recursive_close(volatile _LOCK_RECURSIVE_T *);
void __lock_recursive_acquire(volatile _LOCK_RECURSIVE_T *);
int __lock_recursive_try_acquire(volatile _LOCK_RECURSIVE_T *);
void __lock_recursive_release(volatile _LOCK_RECURSIVE_T *);

typedef _LOCK_FAIR_T _LOCK_T;
# 14 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/_types.h" 2 3


typedef long _off_t;







typedef short __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;
# 45 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/_types.h" 3
typedef long _fpos_t;
# 57 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/_types.h" 3
typedef int _ssize_t;







# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 1 3
# 149 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 3
typedef unsigned int wint_t;
# 65 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/reent.h" 2 3






typedef unsigned long __ULong;
# 36 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/reent.h" 3
struct _reent;
# 45 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 78 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;


  void * _cookie;

  __attribute__((fptrgroup("__sread",0)))
  int (*_read) (struct _reent *, void *, char *, int);

  __attribute__((fptrgroup("__swrite",0)))
  int (*_write) (struct _reent *, void *, const char *, int);

  __attribute__((fptrgroup("__sseek",0)))
  _fpos_t (*_seek) (struct _reent *, void *, _fpos_t, int);
  __attribute__((fptrgroup("__sclose",0)))
  int (*_close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  int _offset;


  _flock_t _lock;

};
# 176 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};







struct _reent;

extern void _cleanup (void);

extern __FILE *__stdin, *__stdout, *__stderr;

__FILE * __getstdin (void);
__FILE * __getstdout (void);
__FILE * __getstderr (void);
# 45 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 2 3


# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 1 3
# 73 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 1 3
# 55 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 3
typedef int ptrdiff_t;
# 94 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 3
typedef unsigned char wchar_t;
# 74 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 2 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/types.h" 1 3
# 19 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 75 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 2 3
# 96 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 3
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort;
typedef unsigned int uint;



typedef unsigned long clock_t;




typedef long time_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;
typedef char * caddr_t;






typedef unsigned short ino_t;
# 166 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;


typedef int pid_t;

typedef long key_t;

typedef _ssize_t ssize_t;
# 190 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 217 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 3
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 248 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;


# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/features.h" 1 3
# 261 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/types.h" 2 3
# 47 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 2 3




typedef __FILE FILE;
# 60 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
typedef _fpos_t fpos_t;






# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/stdio.h" 1 3
# 66 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 2 3
# 161 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);

void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);

int fprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int fscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int printf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));

int scanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)));

int sscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int vfprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)));

int vsprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);
FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int remove (const char *);
int rename (const char *, const char *);

int snprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int vfscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)));

int vsnprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int vsscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));







int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);

int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

char * asnprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));


int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));


int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));

int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)));

int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)));

int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)));

int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));
# 300 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
FILE * fdopen (int, const char *);
int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 323 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
int dprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));


FILE * fmemopen (void *, size_t, const char *);


FILE * open_memstream (char **, size_t *);




int vdprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));







int _fflush (FILE *);
char * _fgets_r (struct _reent *, char *, int, FILE *);
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *, FILE *);
int _fscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

long _ftell_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * , size_t _size, size_t _n, FILE *);
int _getc_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int _mkstemp_r (struct _reent *, char *);
char * _mktemp_r (struct _reent *, char *);
void _perror_r (struct _reent *, const char *);
int _putc_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new);

int _scanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

int _sscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

int _ungetc_r (struct _reent *, int, FILE *);
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));

int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));

int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int _vscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));

int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));


ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 413 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
int __srget (FILE *);
int __swbuf (int, FILE *);
# 429 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie));
# 441 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdio.h" 3
typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions);
# 39 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdlib.h" 1 3
# 14 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 1 3
# 14 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdlib.h" 2 3



# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/stdlib.h" 1 3
# 26 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\machine/stdlib.h" 3
void qsort2 (void * __base, unsigned short __nel, size_t __width, int(*__less)(const void *, const void *), void * __scratch);
# 17 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdlib.h" 2 3


# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\alloca.h" 1 3
# 19 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdlib.h" 2 3
# 28 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdlib.h" 3
typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;
# 57 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdlib.h" 3
extern int __mb_cur_max;



void abort (void) __attribute__ ((noreturn));
int abs (int);



int atexit (void (*__func)(void));

double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
long atol (const char *__nptr);



void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *));





void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) ;
char * getenv (const char *__string);
char * _findenv (const char *, int *);
long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;

int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);


int mkstemp (char *);
char * mktemp (char *);






void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));

int rand (void);
void * realloc (void * __r, size_t __size) ;
void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);

int system (const char *__string);

void _Exit (int __status) __attribute__ ((noreturn));
long long atoll (const char *__nptr);
long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *__n, char **__end_PTR, int __base);
unsigned long long strtoull (const char *__n, char **__end_PTR, int __base);


long a64l (const char *__input);
char * l64a (long __input);



int on_exit (void (*__func)(int, void *),void * __arg);

int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
int setenv (const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);
int rand_r (unsigned *__seed);

double drand48 (void);
double erand48 (unsigned short [3]);
long jrand48 (unsigned short [3]);
void lcong48 (unsigned short [7]);
long lrand48 (void);
long mrand48 (void);
long nrand48 (unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
void srand48 (long);
long long _atoll_r (struct _reent *, const char *__nptr);
long long _strtoll_r (struct _reent *, const char *__n, char **__end_PTR, int __base);
unsigned long long _strtoull_r (struct _reent *, const char *__n, char **__end_PTR, int __base);


void cfree (void *);
void unsetenv (const char *__string);


char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);
# 40 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\string.h" 1 3
# 15 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\string.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 1 3
# 15 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\string.h" 2 3








void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *, const void *, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *__s1, const char *__s2);

int strcoll (const char *, const char *);

char *strcpy (char *, const char *);
size_t strcspn (const char *__s1, const char *__s2);
char *strerror (int);
size_t strlen (const char *__s);
char *strncat (char *, const char *, size_t);
int strncmp (const char *__s1, const char *__s2, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *__s1, const char *__s2);
char *strstr (const char *, const char *);

char *strtok (char *, const char *);



size_t strxfrm (char *, const char *, size_t);



char *strtok_r (char *, const char *, char **);

int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);
void * memccpy (void *, const void *, int, size_t);
void * mempcpy (void *, const void *, size_t);
void * memmem (const void *, size_t, const void *, size_t);
char *rindex (const char *, int);
char *stpcpy (char *, const char *);
char *stpncpy (char *, const char *, size_t);
int strcasecmp (const char *, const char *);
char *strcasestr (const char *, const char *);
char *strdup (const char *);
char *strndup (const char *, size_t);
char *strerror_r (int, char *, size_t);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
int strncasecmp (const char *, const char *, size_t);
size_t strnlen (const char *, size_t);
char *strsep (char **, const char *);
char *strlwr (char *);
char *strupr (char *);
# 102 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\string.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/string.h" 1 3
# 102 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\string.h" 2 3
# 41 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2





# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h" 1
# 42 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h"
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 1 3
# 43 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h" 2
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stdarg.h" 1 3
# 44 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h" 2





# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\unistd.h" 1 3



# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/unistd.h" 1 3
# 13 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/unistd.h" 3
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include/clang\\stddef.h" 1 3
# 14 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/unistd.h" 2 3

extern char **environ;

void _exit (int __status ) __attribute__ ((noreturn));

int access (const char *__path, int __amode );
unsigned alarm (unsigned __secs );
int chdir (const char *__path );
int chmod (const char *__path, mode_t __mode );

int chown (const char *__path, uid_t __owner, gid_t __group );




int close (int __fildes );



char *ctermid (char *__s );
char *cuserid (char *__s );



int dup (int __fildes );
int dup2 (int __fildes, int __fildes2 );



int execl (const char *__path, const char *, ... );
int execle (const char *__path, const char *, ... );
int execlp (const char *__file, const char *, ... );
int execv (const char *__path, char * const *__argv );
int execve (const char *__path, char * const *__argv, char * const *__envp );
int execvp (const char *__file, char * const *__argv );






int fchmod (int __fildes, mode_t __mode );

int fchown (int __fildes, uid_t __owner, gid_t __group );




pid_t fork (void );
long fpathconf (int __fd, int __name );
int fsync (int __fd);
int fdatasync (int __fd);
char *getcwd (char *__buf, size_t __size );




gid_t getegid (void );
uid_t geteuid (void );
gid_t getgid (void );

int getgroups (int __gidsetsize, gid_t *__grouplist );



char *getlogin (void );



char *getpass (const char *__prompt);
size_t getpagesize (void);



pid_t getpgid (pid_t);
pid_t getpgrp (void );
pid_t getpid (void );
pid_t getppid (void );




uid_t getuid (void );






int isatty (int __fildes );

int lchown (const char *__path, uid_t __owner, gid_t __group );

int link (const char *__path1, const char *__path2 );



int nice (int __nice_value );

off_t lseek (int __fildes, off_t __offset, int __whence );
# 122 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/unistd.h" 3
long pathconf (const char *__path, int __name );
int pause (void );



int pipe (int __fildes[2] );
ssize_t pread (int __fd, void *__buf, size_t __nbytes, off_t __offset);
ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, off_t __offset);
int read (int __fd, void *__buf, size_t __nbyte );




int rmdir (const char *__path );



void * sbrk (ptrdiff_t __incr);





int setgid (gid_t __gid );




int setpgid (pid_t __pid, pid_t __pgid );
int setpgrp (void );




pid_t setsid (void );

int setuid (uid_t __uid );




unsigned sleep (unsigned int __seconds );
void swab (const void *, void *, ssize_t);
long sysconf (int __name );
pid_t tcgetpgrp (int __fildes );
int tcsetpgrp (int __fildes, pid_t __pgrp_id );
char *ttyname (int __fildes );



int unlink (const char *__path );
int usleep (useconds_t __useconds);
int vhangup (void );
int write (int __fd, const void *__buf, size_t __nbyte );






extern char *optarg;
extern int optind, opterr, optopt;
int getopt(int, char * const *, const char *);
extern int optreset;



pid_t vfork (void );

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);
# 238 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/unistd.h" 3
ssize_t readlink (const char *__path, char *__buf, size_t __buflen);



int symlink (const char *__name1, const char *__name2);
# 4 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\unistd.h" 2 3
# 50 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h" 2
# 122 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h"
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\utime.h" 1 3







# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/utime.h" 1 3
# 12 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\sys/utime.h" 3
struct utimbuf
{
  time_t actime;
  time_t modtime;
};
# 8 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\utime.h" 2 3
# 123 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h" 2
# 230 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/compat.h"
int flac_snprintf(char *str, size_t size, const char *fmt, ...);
int flac_vsnprintf(char *str, size_t size, const char *fmt, va_list va);
# 47 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/assert.h" 1
# 48 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h" 1
# 37 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/export.h" 1
# 107 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/export.h"
extern int FLAC_API_SUPPORTS_OGG_FLAC;
# 38 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h" 1
# 37 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/ordinals.h" 1
# 55 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/ordinals.h"
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 1 3
# 45 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
typedef signed char int8_t ;
typedef unsigned char uint8_t ;




typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;




typedef signed short int16_t;
typedef unsigned short uint16_t;
# 71 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;
# 83 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
typedef signed long int32_t;
typedef unsigned long uint32_t;
# 101 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;
# 123 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
typedef signed long long int64_t;
typedef unsigned long long uint64_t;
# 133 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;
# 163 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
  typedef signed int int_fast8_t;
  typedef unsigned int uint_fast8_t;




  typedef signed int int_fast16_t;
  typedef unsigned int uint_fast16_t;




  typedef signed int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 217 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
  typedef int_least64_t int_fast64_t;
  typedef uint_least64_t uint_fast64_t;







  typedef long long int intmax_t;
# 235 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
  typedef long long unsigned int uintmax_t;
# 247 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\stdint.h" 3
typedef signed int intptr_t;
typedef unsigned int uintptr_t;
# 56 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/ordinals.h" 2

typedef int8_t FLAC__int8;
typedef uint8_t FLAC__uint8;

typedef int16_t FLAC__int16;
typedef int32_t FLAC__int32;
typedef int64_t FLAC__int64;
typedef uint16_t FLAC__uint16;
typedef uint32_t FLAC__uint32;
typedef uint64_t FLAC__uint64;



typedef int FLAC__bool;

typedef FLAC__uint8 FLAC__byte;
# 38 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h" 2
# 159 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
extern const char *FLAC__VERSION_STRING;





extern const char *FLAC__VENDOR_STRING;


extern const FLAC__byte FLAC__STREAM_SYNC_STRING[4];




extern const uint32_t FLAC__STREAM_SYNC;


extern const uint32_t FLAC__STREAM_SYNC_LEN;
# 191 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
typedef enum {
 FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE = 0,



 FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 = 1


} FLAC__EntropyCodingMethodType;






extern const char * const FLAC__EntropyCodingMethodTypeString[];




typedef struct {

 uint32_t *parameters;


 uint32_t *raw_bits;




 uint32_t capacity_by_order;




} FLAC__EntropyCodingMethod_PartitionedRiceContents;



typedef struct {

 uint32_t order;


 const FLAC__EntropyCodingMethod_PartitionedRiceContents *contents;


} FLAC__EntropyCodingMethod_PartitionedRice;

extern const uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN;
extern const uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
extern const uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN;
extern const uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN;

extern const uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;

extern const uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER;




typedef struct {
 FLAC__EntropyCodingMethodType type;
 union {
  FLAC__EntropyCodingMethod_PartitionedRice partitioned_rice;
 } data;
} FLAC__EntropyCodingMethod;

extern const uint32_t FLAC__ENTROPY_CODING_METHOD_TYPE_LEN;




typedef enum {
 FLAC__SUBFRAME_TYPE_CONSTANT = 0,
 FLAC__SUBFRAME_TYPE_VERBATIM = 1,
 FLAC__SUBFRAME_TYPE_FIXED = 2,
 FLAC__SUBFRAME_TYPE_LPC = 3
} FLAC__SubframeType;






extern const char * const FLAC__SubframeTypeString[];




typedef struct {
 FLAC__int64 value;
} FLAC__Subframe_Constant;


typedef enum {
 FLAC__VERBATIM_SUBFRAME_DATA_TYPE_INT32,
 FLAC__VERBATIM_SUBFRAME_DATA_TYPE_INT64
} FLAC__VerbatimSubframeDataType;




typedef struct {
 union {
  const FLAC__int32 *int32;
  const FLAC__int64 *int64;
 } data;
 FLAC__VerbatimSubframeDataType data_type;
} FLAC__Subframe_Verbatim;




typedef struct {
 FLAC__EntropyCodingMethod entropy_coding_method;


 uint32_t order;


 FLAC__int64 warmup[(4u)];


 const FLAC__int32 *residual;

} FLAC__Subframe_Fixed;




typedef struct {
 FLAC__EntropyCodingMethod entropy_coding_method;


 uint32_t order;


 uint32_t qlp_coeff_precision;


 int quantization_level;


 FLAC__int32 qlp_coeff[(32u)];


 FLAC__int64 warmup[(32u)];


 const FLAC__int32 *residual;

} FLAC__Subframe_LPC;

extern const uint32_t FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN;
extern const uint32_t FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN;




typedef struct {
 FLAC__SubframeType type;
 union {
  FLAC__Subframe_Constant constant;
  FLAC__Subframe_Fixed fixed;
  FLAC__Subframe_LPC lpc;
  FLAC__Subframe_Verbatim verbatim;
 } data;
 uint32_t wasted_bits;
} FLAC__Subframe;
# 369 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
extern const uint32_t FLAC__SUBFRAME_ZERO_PAD_LEN;
extern const uint32_t FLAC__SUBFRAME_TYPE_LEN;
extern const uint32_t FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN;

extern const uint32_t FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK;
extern const uint32_t FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK;
extern const uint32_t FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK;
extern const uint32_t FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK;
# 388 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
typedef enum {
 FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT = 0,
 FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE = 1,
 FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE = 2,
 FLAC__CHANNEL_ASSIGNMENT_MID_SIDE = 3
} FLAC__ChannelAssignment;






extern const char * const FLAC__ChannelAssignmentString[];


typedef enum {
 FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER,
 FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER
} FLAC__FrameNumberType;






extern const char * const FLAC__FrameNumberTypeString[];




typedef struct {
 uint32_t blocksize;


 uint32_t sample_rate;


 uint32_t channels;


 FLAC__ChannelAssignment channel_assignment;


 uint32_t bits_per_sample;


 FLAC__FrameNumberType number_type;




 union {
  FLAC__uint32 frame_number;
  FLAC__uint64 sample_number;
 } number;



 FLAC__uint8 crc;




} FLAC__FrameHeader;

extern const uint32_t FLAC__FRAME_HEADER_SYNC;
extern const uint32_t FLAC__FRAME_HEADER_SYNC_LEN;
extern const uint32_t FLAC__FRAME_HEADER_RESERVED_LEN;
extern const uint32_t FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN;
extern const uint32_t FLAC__FRAME_HEADER_BLOCK_SIZE_LEN;
extern const uint32_t FLAC__FRAME_HEADER_SAMPLE_RATE_LEN;
extern const uint32_t FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN;
extern const uint32_t FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN;
extern const uint32_t FLAC__FRAME_HEADER_ZERO_PAD_LEN;
extern const uint32_t FLAC__FRAME_HEADER_CRC_LEN;




typedef struct {
 FLAC__uint16 crc;




} FLAC__FrameFooter;

extern const uint32_t FLAC__FRAME_FOOTER_CRC_LEN;




typedef struct {
 FLAC__FrameHeader header;
 FLAC__Subframe subframes[(8u)];
 FLAC__FrameFooter footer;
} FLAC__Frame;
# 496 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
typedef enum {

 FLAC__METADATA_TYPE_STREAMINFO = 0,


 FLAC__METADATA_TYPE_PADDING = 1,


 FLAC__METADATA_TYPE_APPLICATION = 2,


 FLAC__METADATA_TYPE_SEEKTABLE = 3,


 FLAC__METADATA_TYPE_VORBIS_COMMENT = 4,


 FLAC__METADATA_TYPE_CUESHEET = 5,


 FLAC__METADATA_TYPE_PICTURE = 6,


 FLAC__METADATA_TYPE_UNDEFINED = 7,


 FLAC__MAX_METADATA_TYPE = (126u),

} FLAC__MetadataType;






extern const char * const FLAC__MetadataTypeString[];




typedef struct {
 uint32_t min_blocksize, max_blocksize;
 uint32_t min_framesize, max_framesize;
 uint32_t sample_rate;
 uint32_t channels;
 uint32_t bits_per_sample;
 FLAC__uint64 total_samples;
 FLAC__byte md5sum[16];
} FLAC__StreamMetadata_StreamInfo;

extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN;
extern const uint32_t FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN;






typedef struct {
 int dummy;




} FLAC__StreamMetadata_Padding;




typedef struct {
 FLAC__byte id[4];
 FLAC__byte *data;
} FLAC__StreamMetadata_Application;

extern const uint32_t FLAC__STREAM_METADATA_APPLICATION_ID_LEN;



typedef struct {
 FLAC__uint64 sample_number;


 FLAC__uint64 stream_offset;



 uint32_t frame_samples;

} FLAC__StreamMetadata_SeekPoint;

extern const uint32_t FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN;
extern const uint32_t FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN;
extern const uint32_t FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN;
# 604 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
extern const FLAC__uint64 FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER;
# 619 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
typedef struct {
 uint32_t num_points;
 FLAC__StreamMetadata_SeekPoint *points;
} FLAC__StreamMetadata_SeekTable;
# 631 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
typedef struct {
 FLAC__uint32 length;
 FLAC__byte *entry;
} FLAC__StreamMetadata_VorbisComment_Entry;

extern const uint32_t FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN;




typedef struct {
 FLAC__StreamMetadata_VorbisComment_Entry vendor_string;
 FLAC__uint32 num_comments;
 FLAC__StreamMetadata_VorbisComment_Entry *comments;
} FLAC__StreamMetadata_VorbisComment;

extern const uint32_t FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN;






typedef struct {
 FLAC__uint64 offset;




 FLAC__byte number;

} FLAC__StreamMetadata_CueSheet_Index;

extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN;






typedef struct {
 FLAC__uint64 offset;


 FLAC__byte number;


 char isrc[13];


 uint32_t type:1;


 uint32_t pre_emphasis:1;


 FLAC__byte num_indices;


 FLAC__StreamMetadata_CueSheet_Index *indices;


} FLAC__StreamMetadata_CueSheet_Track;

extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN;






typedef struct {
 char media_catalog_number[129];





 FLAC__uint64 lead_in;


 FLAC__bool is_cd;


 uint32_t num_tracks;


 FLAC__StreamMetadata_CueSheet_Track *tracks;


} FLAC__StreamMetadata_CueSheet;

extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN;
extern const uint32_t FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN;



typedef enum {
 FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER = 0,
 FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD = 1,
 FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON = 2,
 FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER = 3,
 FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER = 4,
 FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE = 5,
 FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA = 6,
 FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST = 7,
 FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST = 8,
 FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR = 9,
 FLAC__STREAM_METADATA_PICTURE_TYPE_BAND = 10,
 FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER = 11,
 FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST = 12,
 FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION = 13,
 FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING = 14,
 FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE = 15,
 FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE = 16,
 FLAC__STREAM_METADATA_PICTURE_TYPE_FISH = 17,
 FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION = 18,
 FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE = 19,
 FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE = 20,
 FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED
} FLAC__StreamMetadata_Picture_Type;







extern const char * const FLAC__StreamMetadata_Picture_TypeString[];





typedef struct {
 FLAC__StreamMetadata_Picture_Type type;


 char *mime_type;
# 791 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
 FLAC__byte *description;






 FLAC__uint32 width;


 FLAC__uint32 height;


 FLAC__uint32 depth;


 FLAC__uint32 colors;




 FLAC__uint32 data_length;


 FLAC__byte *data;


} FLAC__StreamMetadata_Picture;

extern const uint32_t FLAC__STREAM_METADATA_PICTURE_TYPE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN;
extern const uint32_t FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN;
extern const uint32_t FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN;
extern const uint32_t FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN;
extern const uint32_t FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN;
extern const uint32_t FLAC__STREAM_METADATA_PICTURE_COLORS_LEN;
extern const uint32_t FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN;






typedef struct {
 FLAC__byte *data;
} FLAC__StreamMetadata_Unknown;




typedef struct FLAC__StreamMetadata {
 FLAC__MetadataType type;




 FLAC__bool is_last;


 uint32_t length;


 union {
  FLAC__StreamMetadata_StreamInfo stream_info;
  FLAC__StreamMetadata_Padding padding;
  FLAC__StreamMetadata_Application application;
  FLAC__StreamMetadata_SeekTable seek_table;
  FLAC__StreamMetadata_VorbisComment vorbis_comment;
  FLAC__StreamMetadata_CueSheet cue_sheet;
  FLAC__StreamMetadata_Picture picture;
  FLAC__StreamMetadata_Unknown unknown;
 } data;


} FLAC__StreamMetadata;

extern const uint32_t FLAC__STREAM_METADATA_IS_LAST_LEN;
extern const uint32_t FLAC__STREAM_METADATA_TYPE_LEN;
extern const uint32_t FLAC__STREAM_METADATA_LENGTH_LEN;
# 890 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_sample_rate_is_valid(uint32_t sample_rate);
# 902 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_blocksize_is_subset(uint32_t blocksize, uint32_t sample_rate);
# 913 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_sample_rate_is_subset(uint32_t sample_rate);
# 927 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_vorbiscomment_entry_name_is_legal(const char *name);
# 943 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_vorbiscomment_entry_value_is_legal(const FLAC__byte *value, uint32_t length);
# 960 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_vorbiscomment_entry_is_legal(const FLAC__byte *entry, uint32_t length);
# 972 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_seektable_is_legal(const FLAC__StreamMetadata_SeekTable *seek_table);
# 986 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         uint32_t FLAC__format_seektable_sort(FLAC__StreamMetadata_SeekTable *seek_table);
# 1006 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_cuesheet_is_legal(const FLAC__StreamMetadata_CueSheet *cue_sheet, FLAC__bool check_cd_da_subset, const char **violation);
# 1024 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/format.h"
         FLAC__bool FLAC__format_picture_is_legal(const FLAC__StreamMetadata_Picture *picture, const char **violation);
# 39 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h" 2
# 202 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef enum {

 FLAC__STREAM_DECODER_SEARCH_FOR_METADATA = 0,


 FLAC__STREAM_DECODER_READ_METADATA,


 FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC,




 FLAC__STREAM_DECODER_READ_FRAME,


 FLAC__STREAM_DECODER_END_OF_STREAM,


 FLAC__STREAM_DECODER_OGG_ERROR,


 FLAC__STREAM_DECODER_SEEK_ERROR,





 FLAC__STREAM_DECODER_ABORTED,


 FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR,




 FLAC__STREAM_DECODER_UNINITIALIZED





} FLAC__StreamDecoderState;






extern const char * const FLAC__StreamDecoderStateString[];




typedef enum {

 FLAC__STREAM_DECODER_INIT_STATUS_OK = 0,


 FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER,




 FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS,


 FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR,


 FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE,



 FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED





} FLAC__StreamDecoderInitStatus;






extern const char * const FLAC__StreamDecoderInitStatusString[];




typedef enum {

 FLAC__STREAM_DECODER_READ_STATUS_CONTINUE,


 FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM,
# 310 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
 FLAC__STREAM_DECODER_READ_STATUS_ABORT


} FLAC__StreamDecoderReadStatus;






extern const char * const FLAC__StreamDecoderReadStatusString[];




typedef enum {

 FLAC__STREAM_DECODER_SEEK_STATUS_OK,


 FLAC__STREAM_DECODER_SEEK_STATUS_ERROR,


 FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED


} FLAC__StreamDecoderSeekStatus;






extern const char * const FLAC__StreamDecoderSeekStatusString[];




typedef enum {

 FLAC__STREAM_DECODER_TELL_STATUS_OK,


 FLAC__STREAM_DECODER_TELL_STATUS_ERROR,


 FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED


} FLAC__StreamDecoderTellStatus;






extern const char * const FLAC__StreamDecoderTellStatusString[];




typedef enum {

 FLAC__STREAM_DECODER_LENGTH_STATUS_OK,


 FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR,


 FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED


} FLAC__StreamDecoderLengthStatus;






extern const char * const FLAC__StreamDecoderLengthStatusString[];




typedef enum {

 FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE,


 FLAC__STREAM_DECODER_WRITE_STATUS_ABORT


} FLAC__StreamDecoderWriteStatus;






extern const char * const FLAC__StreamDecoderWriteStatusString[];
# 431 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef enum {

 FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC,


 FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER,


 FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH,


 FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM,


 FLAC__STREAM_DECODER_ERROR_STATUS_BAD_METADATA


} FLAC__StreamDecoderErrorStatus;






extern const char * const FLAC__StreamDecoderErrorStatusString[];
# 464 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
struct FLAC__StreamDecoderProtected;
struct FLAC__StreamDecoderPrivate;




typedef struct {
 struct FLAC__StreamDecoderProtected *protected_;
 struct FLAC__StreamDecoderPrivate *private_;
} FLAC__StreamDecoder;
# 524 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderReadStatus (*FLAC__StreamDecoderReadCallback)(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
# 559 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderSeekStatus (*FLAC__StreamDecoderSeekCallback)(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data);
# 597 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderTellStatus (*FLAC__StreamDecoderTellCallback)(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data);
# 635 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderLengthStatus (*FLAC__StreamDecoderLengthCallback)(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data);
# 662 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef FLAC__bool (*FLAC__StreamDecoderEofCallback)(const FLAC__StreamDecoder *decoder, void *client_data);
# 690 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderWriteStatus (*FLAC__StreamDecoderWriteCallback)(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data);
# 717 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef void (*FLAC__StreamDecoderMetadataCallback)(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data);
# 734 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
typedef void (*FLAC__StreamDecoderErrorCallback)(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);
# 750 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoder *FLAC__stream_decoder_new(void);







         void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder);
# 783 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_ogg_serial_number(FLAC__StreamDecoder *decoder, long serial_number);
# 805 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_md5_checking(FLAC__StreamDecoder *decoder, FLAC__bool value);
# 819 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_metadata_respond(FLAC__StreamDecoder *decoder, FLAC__MetadataType type);
# 834 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_metadata_respond_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4]);
# 846 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder);
# 860 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_metadata_ignore(FLAC__StreamDecoder *decoder, FLAC__MetadataType type);
# 875 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_metadata_ignore_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4]);
# 887 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_set_metadata_ignore_all(FLAC__StreamDecoder *decoder);
# 897 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoderState FLAC__stream_decoder_get_state(const FLAC__StreamDecoder *decoder);
# 907 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         const char *FLAC__stream_decoder_get_resolved_state_string(const FLAC__StreamDecoder *decoder);
# 921 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_get_md5_checking(const FLAC__StreamDecoder *decoder);
# 933 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__uint64 FLAC__stream_decoder_get_total_samples(const FLAC__StreamDecoder *decoder);
# 945 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         uint32_t FLAC__stream_decoder_get_channels(const FLAC__StreamDecoder *decoder);
# 957 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__ChannelAssignment FLAC__stream_decoder_get_channel_assignment(const FLAC__StreamDecoder *decoder);
# 969 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         uint32_t FLAC__stream_decoder_get_bits_per_sample(const FLAC__StreamDecoder *decoder);
# 981 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         uint32_t FLAC__stream_decoder_get_sample_rate(const FLAC__StreamDecoder *decoder);
# 993 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         uint32_t FLAC__stream_decoder_get_blocksize(const FLAC__StreamDecoder *decoder);
# 1014 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_get_decode_position(const FLAC__StreamDecoder *decoder, FLAC__uint64 *position);
# 1024 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         const void *FLAC__stream_decoder_get_client_data(FLAC__StreamDecoder *decoder);
# 1090 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(
 FLAC__StreamDecoder *decoder,
 FLAC__StreamDecoderReadCallback read_callback,
 FLAC__StreamDecoderSeekCallback seek_callback,
 FLAC__StreamDecoderTellCallback tell_callback,
 FLAC__StreamDecoderLengthCallback length_callback,
 FLAC__StreamDecoderEofCallback eof_callback,
 FLAC__StreamDecoderWriteCallback write_callback,
 FLAC__StreamDecoderMetadataCallback metadata_callback,
 FLAC__StreamDecoderErrorCallback error_callback,
 void *client_data
);
# 1171 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_stream(
 FLAC__StreamDecoder *decoder,
 FLAC__StreamDecoderReadCallback read_callback,
 FLAC__StreamDecoderSeekCallback seek_callback,
 FLAC__StreamDecoderTellCallback tell_callback,
 FLAC__StreamDecoderLengthCallback length_callback,
 FLAC__StreamDecoderEofCallback eof_callback,
 FLAC__StreamDecoderWriteCallback write_callback,
 FLAC__StreamDecoderMetadataCallback metadata_callback,
 FLAC__StreamDecoderErrorCallback error_callback,
 void *client_data
);
# 1221 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_FILE(
 FLAC__StreamDecoder *decoder,
 FILE *file,
 FLAC__StreamDecoderWriteCallback write_callback,
 FLAC__StreamDecoderMetadataCallback metadata_callback,
 FLAC__StreamDecoderErrorCallback error_callback,
 void *client_data
);
# 1271 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_FILE(
 FLAC__StreamDecoder *decoder,
 FILE *file,
 FLAC__StreamDecoderWriteCallback write_callback,
 FLAC__StreamDecoderMetadataCallback metadata_callback,
 FLAC__StreamDecoderErrorCallback error_callback,
 void *client_data
);
# 1317 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_file(
 FLAC__StreamDecoder *decoder,
 const char *filename,
 FLAC__StreamDecoderWriteCallback write_callback,
 FLAC__StreamDecoderMetadataCallback metadata_callback,
 FLAC__StreamDecoderErrorCallback error_callback,
 void *client_data
);
# 1367 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_file(
 FLAC__StreamDecoder *decoder,
 const char *filename,
 FLAC__StreamDecoderWriteCallback write_callback,
 FLAC__StreamDecoderMetadataCallback metadata_callback,
 FLAC__StreamDecoderErrorCallback error_callback,
 void *client_data
);
# 1395 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder);
# 1410 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_flush(FLAC__StreamDecoder *decoder);
# 1442 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_reset(FLAC__StreamDecoder *decoder);
# 1475 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder);
# 1496 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder);
# 1517 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_process_until_end_of_stream(FLAC__StreamDecoder *decoder);
# 1558 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_skip_single_frame(FLAC__StreamDecoder *decoder);
# 1576 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/FLAC/stream_decoder.h"
         FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder, FLAC__uint64 sample);
# 49 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/stream_encoder.h" 1
# 37 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/stream_encoder.h"
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h" 1
# 241 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
typedef enum {

 FLAC__STREAM_ENCODER_OK = 0,


 FLAC__STREAM_ENCODER_UNINITIALIZED,





 FLAC__STREAM_ENCODER_OGG_ERROR,


 FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR,




 FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA,




 FLAC__STREAM_ENCODER_CLIENT_ERROR,


 FLAC__STREAM_ENCODER_IO_ERROR,




 FLAC__STREAM_ENCODER_FRAMING_ERROR,




 FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR


} FLAC__StreamEncoderState;






extern const char * const FLAC__StreamEncoderStateString[];




typedef enum {

 FLAC__STREAM_ENCODER_INIT_STATUS_OK = 0,


 FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR,


 FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER,




 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS,


 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS,


 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE,




 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE,


 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE,


 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER,


 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION,


 FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER,


 FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE,


 FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA,
# 344 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
 FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED





} FLAC__StreamEncoderInitStatus;






extern const char * const FLAC__StreamEncoderInitStatusString[];




typedef enum {

 FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE,


 FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM,


 FLAC__STREAM_ENCODER_READ_STATUS_ABORT,


 FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED


} FLAC__StreamEncoderReadStatus;






extern const char * const FLAC__StreamEncoderReadStatusString[];




typedef enum {

 FLAC__STREAM_ENCODER_WRITE_STATUS_OK = 0,


 FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR


} FLAC__StreamEncoderWriteStatus;






extern const char * const FLAC__StreamEncoderWriteStatusString[];




typedef enum {

 FLAC__STREAM_ENCODER_SEEK_STATUS_OK,


 FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR,


 FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED


} FLAC__StreamEncoderSeekStatus;






extern const char * const FLAC__StreamEncoderSeekStatusString[];




typedef enum {

 FLAC__STREAM_ENCODER_TELL_STATUS_OK,


 FLAC__STREAM_ENCODER_TELL_STATUS_ERROR,


 FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED


} FLAC__StreamEncoderTellStatus;






extern const char * const FLAC__StreamEncoderTellStatusString[];
# 458 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
struct FLAC__StreamEncoderProtected;
struct FLAC__StreamEncoderPrivate;




typedef struct {
 struct FLAC__StreamEncoderProtected *protected_;
 struct FLAC__StreamEncoderPrivate *private_;
} FLAC__StreamEncoder;
# 518 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderReadStatus (*FLAC__StreamEncoderReadCallback)(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
# 556 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderWriteStatus (*FLAC__StreamEncoderWriteCallback)(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, uint32_t samples, uint32_t current_frame, void *client_data);
# 590 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderSeekStatus (*FLAC__StreamEncoderSeekCallback)(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data);
# 635 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderTellStatus (*FLAC__StreamEncoderTellCallback)(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data);
# 654 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
typedef void (*FLAC__StreamEncoderMetadataCallback)(const FLAC__StreamEncoder *encoder, const FLAC__StreamMetadata *metadata, void *client_data);
# 677 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
typedef void (*FLAC__StreamEncoderProgressCallback)(const FLAC__StreamEncoder *encoder, FLAC__uint64 bytes_written, FLAC__uint64 samples_written, uint32_t frames_written, uint32_t total_frames_estimate, void *client_data);
# 693 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoder *FLAC__stream_encoder_new(void);







         void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder);
# 727 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_ogg_serial_number(FLAC__StreamEncoder *encoder, long serial_number);
# 743 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_verify(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 761 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_streamable_subset(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 773 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder, uint32_t value);
# 789 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value);
# 801 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder, uint32_t value);
# 864 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder, uint32_t value);
# 879 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_blocksize(FLAC__StreamEncoder *encoder, uint32_t value);
# 893 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_do_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 909 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_loose_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 991 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_apodization(FLAC__StreamEncoder *encoder, const char *specification);
# 1003 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_max_lpc_order(FLAC__StreamEncoder *encoder, uint32_t value);
# 1017 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_qlp_coeff_precision(FLAC__StreamEncoder *encoder, uint32_t value);
# 1031 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_do_qlp_coeff_prec_search(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 1043 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_do_escape_coding(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 1057 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_do_exhaustive_model_search(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 1080 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_min_residual_partition_order(FLAC__StreamEncoder *encoder, uint32_t value);
# 1103 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_max_residual_partition_order(FLAC__StreamEncoder *encoder, uint32_t value);
# 1115 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_rice_parameter_search_dist(FLAC__StreamEncoder *encoder, uint32_t value);
# 1131 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_total_samples_estimate(FLAC__StreamEncoder *encoder, FLAC__uint64 value);
# 1214 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder, FLAC__StreamMetadata **metadata, uint32_t num_blocks);
# 1232 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_set_limit_min_bitrate(FLAC__StreamEncoder *encoder, FLAC__bool value);
# 1242 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoderState FLAC__stream_encoder_get_state(const FLAC__StreamEncoder *encoder);
# 1254 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamDecoderState FLAC__stream_encoder_get_verify_decoder_state(const FLAC__StreamEncoder *encoder);
# 1267 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         const char *FLAC__stream_encoder_get_resolved_state_string(const FLAC__StreamEncoder *encoder);
# 1286 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         void FLAC__stream_encoder_get_verify_decoder_error_stats(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_sample, uint32_t *frame_number, uint32_t *channel, uint32_t *sample, FLAC__int32 *expected, FLAC__int32 *got);
# 1296 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_verify(const FLAC__StreamEncoder *encoder);
# 1306 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_streamable_subset(const FLAC__StreamEncoder *encoder);
# 1316 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_channels(const FLAC__StreamEncoder *encoder);
# 1326 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_bits_per_sample(const FLAC__StreamEncoder *encoder);
# 1336 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_sample_rate(const FLAC__StreamEncoder *encoder);
# 1346 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_blocksize(const FLAC__StreamEncoder *encoder);
# 1356 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_do_mid_side_stereo(const FLAC__StreamEncoder *encoder);
# 1366 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_loose_mid_side_stereo(const FLAC__StreamEncoder *encoder);
# 1376 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_max_lpc_order(const FLAC__StreamEncoder *encoder);
# 1386 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_qlp_coeff_precision(const FLAC__StreamEncoder *encoder);
# 1396 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_do_qlp_coeff_prec_search(const FLAC__StreamEncoder *encoder);
# 1406 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_do_escape_coding(const FLAC__StreamEncoder *encoder);
# 1416 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_do_exhaustive_model_search(const FLAC__StreamEncoder *encoder);
# 1426 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_min_residual_partition_order(const FLAC__StreamEncoder *encoder);
# 1436 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_max_residual_partition_order(const FLAC__StreamEncoder *encoder);
# 1446 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         uint32_t FLAC__stream_encoder_get_rice_parameter_search_dist(const FLAC__StreamEncoder *encoder);
# 1459 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__uint64 FLAC__stream_encoder_get_total_samples_estimate(const FLAC__StreamEncoder *encoder);
# 1469 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_get_limit_min_bitrate(const FLAC__StreamEncoder *encoder);
# 1532 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(FLAC__StreamEncoder *encoder, FLAC__StreamEncoderWriteCallback write_callback, FLAC__StreamEncoderSeekCallback seek_callback, FLAC__StreamEncoderTellCallback tell_callback, FLAC__StreamEncoderMetadataCallback metadata_callback, void *client_data);
# 1600 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_stream(FLAC__StreamEncoder *encoder, FLAC__StreamEncoderReadCallback read_callback, FLAC__StreamEncoderWriteCallback write_callback, FLAC__StreamEncoderSeekCallback seek_callback, FLAC__StreamEncoderTellCallback tell_callback, FLAC__StreamEncoderMetadataCallback metadata_callback, void *client_data);
# 1635 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_FILE(FLAC__StreamEncoder *encoder, FILE *file, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);
# 1670 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_FILE(FLAC__StreamEncoder *encoder, FILE *file, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);
# 1706 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_file(FLAC__StreamEncoder *encoder, const char *filename, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);
# 1742 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_file(FLAC__StreamEncoder *encoder, const char *filename, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);
# 1770 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder);
# 1797 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], uint32_t samples);
# 1829 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../FLAC/stream_encoder.h"
         FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder, const FLAC__int32 buffer[], uint32_t samples);
# 38 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/stream_encoder.h" 2







# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../private/float.h" 1
# 56 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/../private/float.h"
typedef float FLAC__real;
# 46 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/protected/stream_encoder.h" 2



typedef enum {
 FLAC__APODIZATION_BARTLETT,
 FLAC__APODIZATION_BARTLETT_HANN,
 FLAC__APODIZATION_BLACKMAN,
 FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE,
 FLAC__APODIZATION_CONNES,
 FLAC__APODIZATION_FLATTOP,
 FLAC__APODIZATION_GAUSS,
 FLAC__APODIZATION_HAMMING,
 FLAC__APODIZATION_HANN,
 FLAC__APODIZATION_KAISER_BESSEL,
 FLAC__APODIZATION_NUTTALL,
 FLAC__APODIZATION_RECTANGLE,
 FLAC__APODIZATION_TRIANGLE,
 FLAC__APODIZATION_TUKEY,
 FLAC__APODIZATION_PARTIAL_TUKEY,
 FLAC__APODIZATION_PUNCHOUT_TUKEY,
 FLAC__APODIZATION_SUBDIVIDE_TUKEY,
 FLAC__APODIZATION_WELCH
} FLAC__ApodizationFunction;

typedef struct {
 FLAC__ApodizationFunction type;
 union {
  struct {
   FLAC__real stddev;
  } gauss;
  struct {
   FLAC__real p;
  } tukey;
  struct {
   FLAC__real p;
   FLAC__real start;
   FLAC__real end;
  } multiple_tukey;
  struct {
   FLAC__real p;
   FLAC__int32 parts;
  } subdivide_tukey;
 } parameters;
} FLAC__ApodizationSpecification;



typedef struct FLAC__StreamEncoderProtected {
 FLAC__StreamEncoderState state;
 FLAC__bool verify;
 FLAC__bool streamable_subset;
 FLAC__bool do_md5;
 FLAC__bool do_mid_side_stereo;
 FLAC__bool loose_mid_side_stereo;
 uint32_t channels;
 uint32_t bits_per_sample;
 uint32_t sample_rate;
 uint32_t blocksize;

 uint32_t num_apodizations;
 FLAC__ApodizationSpecification apodizations[32];

 uint32_t max_lpc_order;
 uint32_t qlp_coeff_precision;
 FLAC__bool do_qlp_coeff_prec_search;
 FLAC__bool do_exhaustive_model_search;
 FLAC__bool do_escape_coding;
 uint32_t min_residual_partition_order;
 uint32_t max_residual_partition_order;
 uint32_t rice_parameter_search_dist;
 FLAC__uint64 total_samples_estimate;
 FLAC__bool limit_min_bitrate;
 FLAC__StreamMetadata **metadata;
 uint32_t num_metadata_blocks;
 FLAC__uint64 streaminfo_offset, seektable_offset, audio_offset;



} FLAC__StreamEncoderProtected;
# 50 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitwriter.h" 1
# 42 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitwriter.h"
struct FLAC__BitWriter;
typedef struct FLAC__BitWriter FLAC__BitWriter;




FLAC__BitWriter *FLAC__bitwriter_new(void);
void FLAC__bitwriter_delete(FLAC__BitWriter *bw);
FLAC__bool FLAC__bitwriter_init(FLAC__BitWriter *bw);
void FLAC__bitwriter_free(FLAC__BitWriter *bw);
void FLAC__bitwriter_clear(FLAC__BitWriter *bw);






FLAC__bool FLAC__bitwriter_get_write_crc16(FLAC__BitWriter *bw, FLAC__uint16 *crc);
FLAC__bool FLAC__bitwriter_get_write_crc8(FLAC__BitWriter *bw, FLAC__byte *crc);




FLAC__bool FLAC__bitwriter_is_byte_aligned(const FLAC__BitWriter *bw);
uint32_t FLAC__bitwriter_get_input_bits_unconsumed(const FLAC__BitWriter *bw);
# 75 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitwriter.h"
FLAC__bool FLAC__bitwriter_get_buffer(FLAC__BitWriter *bw, const FLAC__byte **buffer, size_t *bytes);
void FLAC__bitwriter_release_buffer(FLAC__BitWriter *bw);




FLAC__bool FLAC__bitwriter_write_zeroes(FLAC__BitWriter *bw, uint32_t bits);
FLAC__bool FLAC__bitwriter_write_raw_uint32(FLAC__BitWriter *bw, FLAC__uint32 val, uint32_t bits);
FLAC__bool FLAC__bitwriter_write_raw_int32(FLAC__BitWriter *bw, FLAC__int32 val, uint32_t bits);
FLAC__bool FLAC__bitwriter_write_raw_uint64(FLAC__BitWriter *bw, FLAC__uint64 val, uint32_t bits);
FLAC__bool FLAC__bitwriter_write_raw_int64(FLAC__BitWriter *bw, FLAC__int64 val, uint32_t bits);
FLAC__bool FLAC__bitwriter_write_raw_uint32_little_endian(FLAC__BitWriter *bw, FLAC__uint32 val);
FLAC__bool FLAC__bitwriter_write_byte_block(FLAC__BitWriter *bw, const FLAC__byte vals[], uint32_t nvals);
FLAC__bool FLAC__bitwriter_write_unary_unsigned(FLAC__BitWriter *bw, uint32_t val);






FLAC__bool FLAC__bitwriter_write_rice_signed_block(FLAC__BitWriter *bw, const FLAC__int32 *vals, uint32_t nvals, uint32_t parameter);




FLAC__bool FLAC__bitwriter_write_utf8_uint32(FLAC__BitWriter *bw, FLAC__uint32 val);
FLAC__bool FLAC__bitwriter_write_utf8_uint64(FLAC__BitWriter *bw, FLAC__uint64 val);
FLAC__bool FLAC__bitwriter_zero_pad_to_byte_boundary(FLAC__BitWriter *bw);
# 51 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitmath.h" 1
# 48 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitmath.h"
static inline uint32_t FLAC__clz_soft_uint32(FLAC__uint32 word)
{
 static const uint8_t byte_to_unary_table[] = {
 8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 };

 return word > 0xffffff ? byte_to_unary_table[word >> 24] :
  word > 0xffff ? byte_to_unary_table[word >> 16] + 8 :
  word > 0xff ? byte_to_unary_table[word >> 8] + 16 :
  byte_to_unary_table[word] + 24;
}

static inline uint32_t FLAC__clz_uint32(FLAC__uint32 v)
{

                    ;





 return __builtin_clz(v);
# 94 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitmath.h"
}


static inline uint32_t FLAC__clz_soft_uint64(FLAC__uint64 word)
{
 return (FLAC__uint32)(word>>32) ? FLAC__clz_uint32((FLAC__uint32)(word>>32)) :
  FLAC__clz_uint32((FLAC__uint32)word) + 32;
}

static inline uint32_t FLAC__clz_uint64(FLAC__uint64 v)
{

                    ;

 return __builtin_clzll(v);
# 118 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitmath.h"
}


static inline uint32_t FLAC__clz2_uint32(FLAC__uint32 v)
{
 if (!v)
  return 32;
 return FLAC__clz_uint32(v);
}

static inline uint32_t FLAC__clz2_uint64(FLAC__uint64 v)
{
 if (!v)
  return 64;
 return FLAC__clz_uint64(v);
}
# 158 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitmath.h"
static inline uint32_t FLAC__bitmath_ilog2(FLAC__uint32 v)
{
                    ;
# 170 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitmath.h"
 return FLAC__clz_uint32(v) ^ 31U;

}

static inline uint32_t FLAC__bitmath_ilog2_wide(FLAC__uint64 v)
{
                    ;

 return __builtin_clzll(v) ^ 63U;
# 208 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/bitmath.h"
}

uint32_t FLAC__bitmath_silog2(FLAC__int64 v);
# 52 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/crc.h" 1
# 43 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/crc.h"
FLAC__uint8 FLAC__crc8(const FLAC__byte *data, uint32_t len);





extern FLAC__uint16 const FLAC__crc16_table[8][256];







FLAC__uint16 FLAC__crc16(const FLAC__byte *data, uint32_t len);
FLAC__uint16 FLAC__crc16_update_words32(const FLAC__uint32 *words, uint32_t len, FLAC__uint16 crc);
FLAC__uint16 FLAC__crc16_update_words64(const FLAC__uint64 *words, uint32_t len, FLAC__uint16 crc);
# 53 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/cpu.h" 1
# 154 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/cpu.h"
typedef enum {
 FLAC__CPUINFO_TYPE_IA32,
 FLAC__CPUINFO_TYPE_X86_64,
 FLAC__CPUINFO_TYPE_PPC,
 FLAC__CPUINFO_TYPE_UNKNOWN
} FLAC__CPUInfo_Type;

typedef struct {
 FLAC__bool intel;

 FLAC__bool cmov;
 FLAC__bool mmx;
 FLAC__bool sse;
 FLAC__bool sse2;

 FLAC__bool sse3;
 FLAC__bool ssse3;
 FLAC__bool sse41;
 FLAC__bool sse42;
 FLAC__bool avx;
 FLAC__bool avx2;
 FLAC__bool fma;
} FLAC__CPUInfo_x86;

typedef struct {
 FLAC__bool arch_3_00;
 FLAC__bool arch_2_07;
} FLAC__CPUInfo_ppc;

typedef struct {
 FLAC__bool use_asm;
 FLAC__CPUInfo_Type type;
 FLAC__CPUInfo_x86 x86;
 FLAC__CPUInfo_ppc ppc;
} FLAC__CPUInfo;

void FLAC__cpu_info(FLAC__CPUInfo *info);

FLAC__uint32 FLAC__cpu_have_cpuid_asm_ia32(void);

void FLAC__cpu_info_asm_ia32(FLAC__uint32 level, FLAC__uint32 *eax, FLAC__uint32 *ebx, FLAC__uint32 *ecx, FLAC__uint32 *edx);
# 54 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/fixed.h" 1
# 60 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/fixed.h"
uint32_t FLAC__fixed_compute_best_predictor(const FLAC__int32 data[], uint32_t data_len, float residual_bits_per_sample[(4u)+1]);
uint32_t FLAC__fixed_compute_best_predictor_wide(const FLAC__int32 data[], uint32_t data_len, float residual_bits_per_sample[(4u)+1]);
uint32_t FLAC__fixed_compute_best_predictor_limit_residual(const FLAC__int32 data[], uint32_t data_len, float residual_bits_per_sample[(4u)+1]);
uint32_t FLAC__fixed_compute_best_predictor_limit_residual_33bit(const FLAC__int64 data[], uint32_t data_len, float residual_bits_per_sample[(4u)+1]);
# 94 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/fixed.h"
void FLAC__fixed_compute_residual(const FLAC__int32 data[], uint32_t data_len, uint32_t order, FLAC__int32 residual[]);
void FLAC__fixed_compute_residual_wide(const FLAC__int32 data[], uint32_t data_len, uint32_t order, FLAC__int32 residual[]);
void FLAC__fixed_compute_residual_wide_33bit(const FLAC__int64 data[], uint32_t data_len, uint32_t order, FLAC__int32 residual[]);
# 111 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/fixed.h"
void FLAC__fixed_restore_signal(const FLAC__int32 residual[], uint32_t data_len, uint32_t order, FLAC__int32 data[]);
void FLAC__fixed_restore_signal_wide(const FLAC__int32 residual[], uint32_t data_len, uint32_t order, FLAC__int32 data[]);
void FLAC__fixed_restore_signal_wide_33bit(const FLAC__int32 residual[], uint32_t data_len, uint32_t order, FLAC__int64 data[]);
# 55 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/format.h" 1
# 42 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/format.h"
uint32_t FLAC__format_get_max_rice_partition_order_from_blocksize(uint32_t blocksize);
uint32_t FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(uint32_t limit, uint32_t blocksize, uint32_t predictor_order);
void FLAC__format_entropy_coding_method_partitioned_rice_contents_init(FLAC__EntropyCodingMethod_PartitionedRiceContents *object);
void FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(FLAC__EntropyCodingMethod_PartitionedRiceContents *object);
FLAC__bool FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(FLAC__EntropyCodingMethod_PartitionedRiceContents *object, uint32_t max_partition_order);
# 56 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h" 1
# 60 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
void FLAC__lpc_window_data(const FLAC__int32 in[], const FLAC__real window[], FLAC__real out[], uint32_t data_len);
void FLAC__lpc_window_data_wide(const FLAC__int64 in[], const FLAC__real window[], FLAC__real out[], uint32_t data_len);
void FLAC__lpc_window_data_partial(const FLAC__int32 in[], const FLAC__real window[], FLAC__real out[], uint32_t data_len, uint32_t part_size, uint32_t data_shift);
void FLAC__lpc_window_data_partial_wide(const FLAC__int64 in[], const FLAC__real window[], FLAC__real out[], uint32_t data_len, uint32_t part_size, uint32_t data_shift);
# 77 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
void FLAC__lpc_compute_autocorrelation(const FLAC__real data[], uint32_t data_len, uint32_t lag, double autoc[]);
# 133 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
void FLAC__lpc_compute_lp_coefficients(const double autoc[], uint32_t *max_order, FLAC__real lp_coeff[][(32u)], double error[]);
# 155 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
int FLAC__lpc_quantize_coefficients(const FLAC__real lp_coeff[], uint32_t order, uint32_t precision, FLAC__int32 qlp_coeff[], int *shift);
# 170 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
void FLAC__lpc_compute_residual_from_qlp_coefficients(const FLAC__int32 *data, uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 residual[]);
void FLAC__lpc_compute_residual_from_qlp_coefficients_wide(const FLAC__int32 *data, uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 residual[]);
FLAC__bool FLAC__lpc_compute_residual_from_qlp_coefficients_limit_residual(const FLAC__int32 *data, uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 residual[]);
FLAC__bool FLAC__lpc_compute_residual_from_qlp_coefficients_limit_residual_33bit(const FLAC__int64 *data, uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 residual[]);
# 199 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
uint32_t FLAC__lpc_max_prediction_before_shift_bps(uint32_t subframe_bps, const FLAC__int32 qlp_coeff[], uint32_t order);
uint32_t FLAC__lpc_max_residual_bps(uint32_t subframe_bps, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization);
# 217 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
void FLAC__lpc_restore_signal(const FLAC__int32 residual[], uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 data[]);
void FLAC__lpc_restore_signal_wide(const FLAC__int32 residual[], uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 data[]);
void FLAC__lpc_restore_signal_wide_33bit(const FLAC__int32 residual[], uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int64 data[]);
# 233 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
double FLAC__lpc_compute_expected_bits_per_residual_sample(double lpc_error, uint32_t total_samples);
double FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(double lpc_error, double error_scale);
# 249 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/lpc.h"
uint32_t FLAC__lpc_compute_best_order(const double lpc_error[], uint32_t max_order, uint32_t total_samples, uint32_t overhead_bits_per_order);
# 57 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/md5.h" 1
# 32 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/md5.h"
typedef union {
 FLAC__byte *p8;
 FLAC__int16 *p16;
 FLAC__int32 *p32;
} FLAC__multibyte;

typedef struct {
 FLAC__uint32 in[16];
 FLAC__uint32 buf[4];
 FLAC__uint32 bytes[2];
 FLAC__multibyte internal_buf;
 size_t capacity;
} FLAC__MD5Context;

void FLAC__MD5Init(FLAC__MD5Context *context);
void FLAC__MD5Final(FLAC__byte digest[16], FLAC__MD5Context *context);

FLAC__bool FLAC__MD5Accumulate(FLAC__MD5Context *ctx, const FLAC__int32 * const signal[], uint32_t channels, uint32_t samples, uint32_t bytes_per_sample);
# 58 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/memory.h" 1
# 50 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/memory.h"
void *FLAC__memory_alloc_aligned(size_t bytes, void **aligned_address);
FLAC__bool FLAC__memory_alloc_aligned_int32_array(size_t elements, FLAC__int32 **unaligned_pointer, FLAC__int32 **aligned_pointer);
FLAC__bool FLAC__memory_alloc_aligned_uint32_array(size_t elements, FLAC__uint32 **unaligned_pointer, FLAC__uint32 **aligned_pointer);
FLAC__bool FLAC__memory_alloc_aligned_int64_array(size_t elements, FLAC__int64 **unaligned_pointer, FLAC__int64 **aligned_pointer);
FLAC__bool FLAC__memory_alloc_aligned_uint64_array(size_t elements, FLAC__uint64 **unaligned_pointer, FLAC__uint64 **aligned_pointer);

FLAC__bool FLAC__memory_alloc_aligned_real_array(size_t elements, FLAC__real **unaligned_pointer, FLAC__real **aligned_pointer);

void *safe_malloc_mul_2op_p(size_t size1, size_t size2);
# 59 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/macros.h" 1
# 60 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2




# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/stream_encoder.h" 1
# 65 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/stream_encoder_framing.h" 1
# 40 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/stream_encoder_framing.h"
FLAC__bool FLAC__add_metadata_block(const FLAC__StreamMetadata *metadata, FLAC__BitWriter *bw);
FLAC__bool FLAC__frame_add_header(const FLAC__FrameHeader *header, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_constant(const FLAC__Subframe_Constant *subframe, uint32_t subframe_bps, uint32_t wasted_bits, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_fixed(const FLAC__Subframe_Fixed *subframe, uint32_t residual_samples, uint32_t subframe_bps, uint32_t wasted_bits, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_lpc(const FLAC__Subframe_LPC *subframe, uint32_t residual_samples, uint32_t subframe_bps, uint32_t wasted_bits, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_verbatim(const FLAC__Subframe_Verbatim *subframe, uint32_t samples, uint32_t subframe_bps, uint32_t wasted_bits, FLAC__BitWriter *bw);
# 66 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/window.h" 1
# 56 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/private/window.h"
void FLAC__window_bartlett(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_bartlett_hann(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_blackman(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_blackman_harris_4term_92db_sidelobe(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_connes(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_flattop(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_gauss(FLAC__real *window, const FLAC__int32 L, const FLAC__real stddev);
void FLAC__window_hamming(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_hann(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_kaiser_bessel(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_nuttall(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_rectangle(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_triangle(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p);
void FLAC__window_partial_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p, const FLAC__real start, const FLAC__real end);
void FLAC__window_punchout_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p, const FLAC__real start, const FLAC__real end);
void FLAC__window_welch(FLAC__real *window, const FLAC__int32 L);
# 67 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/alloc.h" 1
# 44 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/alloc.h"
# 1 "C:\\Program Files (x86)\\XMOS\\xTIMEcomposer\\Community_14.4.1\\target/include\\limits.h" 1 3
# 45 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/alloc.h" 2
# 85 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/alloc.h"
static inline void *safe_malloc_(size_t size)
{






 if(!size)
  size++;
 return malloc(size);
}
# 112 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/alloc.h"
static inline void *safe_calloc_(size_t nmemb, size_t size)
{





 if(!nmemb || !size)
  return malloc(1);
 return calloc(nmemb, size);
}



static inline void *safe_malloc_add_2op_(size_t size1, size_t size2)
{
 size2 += size1;
 if(size2 < size1)
  return 0;
 return safe_malloc_(size2);
}

static inline void *safe_malloc_add_3op_(size_t size1, size_t size2, size_t size3)
{
 size2 += size1;
 if(size2 < size1)
  return 0;
 size3 += size2;
 if(size3 < size2)
  return 0;
 return safe_malloc_(size3);
}

static inline void *safe_malloc_add_4op_(size_t size1, size_t size2, size_t size3, size_t size4)
{
 size2 += size1;
 if(size2 < size1)
  return 0;
 size3 += size2;
 if(size3 < size2)
  return 0;
 size4 += size3;
 if(size4 < size3)
  return 0;
 return safe_malloc_(size4);
}

void *safe_malloc_mul_2op_(size_t size1, size_t size2) ;

static inline void *safe_malloc_mul_3op_(size_t size1, size_t size2, size_t size3)
{
 if(!size1 || !size2 || !size3)
  return malloc(1);
 if(size1 > (2147483647L * 2UL + 1) / size2)
  return 0;
 size1 *= size2;
 if(size1 > (2147483647L * 2UL + 1) / size3)
  return 0;
 return malloc(size1*size3);
}


static inline void *safe_malloc_mul2add_(size_t size1, size_t size2, size_t size3)
{
 if(!size1 || !size2)
  return safe_malloc_(size3);
 if(size1 > (2147483647L * 2UL + 1) / size2)
  return 0;
 return safe_malloc_add_2op_(size1*size2, size3);
}


static inline void *safe_malloc_muladd2_(size_t size1, size_t size2, size_t size3)
{
 if(!size1 || (!size2 && !size3))
  return malloc(1);
 size2 += size3;
 if(size2 < size3)
  return 0;
 if(size1 > (2147483647L * 2UL + 1) / size2)
  return 0;
 return malloc(size1*size2);
}

static inline void *safe_realloc_(void *ptr, size_t size)
{







 void *oldptr = ptr;
 void *newptr = realloc(ptr, size);
 if(size > 0 && newptr == 0)
  free(oldptr);
 return newptr;
}
# 225 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/alloc.h"
static inline void *safe_realloc_nofree_add_2op_(void *ptr, size_t size1, size_t size2)
{
 size2 += size1;
 if(size2 < size1)
  return 0;
 return realloc(ptr, size2);
}

static inline void *safe_realloc_add_3op_(void *ptr, size_t size1, size_t size2, size_t size3)
{
 size2 += size1;
 if(size2 < size1) {
  free(ptr);
  return 0;
 }
 size3 += size2;
 if(size3 < size2) {
  free(ptr);
  return 0;
 }
 return safe_realloc_(ptr, size3);
}

static inline void *safe_realloc_nofree_add_3op_(void *ptr, size_t size1, size_t size2, size_t size3)
{
 size2 += size1;
 if(size2 < size1)
  return 0;
 size3 += size2;
 if(size3 < size2)
  return 0;
 return realloc(ptr, size3);
}

static inline void *safe_realloc_nofree_add_4op_(void *ptr, size_t size1, size_t size2, size_t size3, size_t size4)
{
 size2 += size1;
 if(size2 < size1)
  return 0;
 size3 += size2;
 if(size3 < size2)
  return 0;
 size4 += size3;
 if(size4 < size3)
  return 0;
 return realloc(ptr, size4);
}

static inline void *safe_realloc_mul_2op_(void *ptr, size_t size1, size_t size2)
{
 if(!size1 || !size2)
  return realloc(ptr, 0);
 if(size1 > (2147483647L * 2UL + 1) / size2) {
  free(ptr);
  return 0;
 }
 return safe_realloc_(ptr, size1*size2);
}

static inline void *safe_realloc_nofree_mul_2op_(void *ptr, size_t size1, size_t size2)
{
 if(!size1 || !size2)
  return realloc(ptr, 0);
 if(size1 > (2147483647L * 2UL + 1) / size2)
  return 0;
 return realloc(ptr, size1*size2);
}


static inline void *safe_realloc_muladd2_(void *ptr, size_t size1, size_t size2, size_t size3)
{
 if(!size1 || (!size2 && !size3))
  return realloc(ptr, 0);
 size2 += size3;
 if(size2 < size3) {
  free(ptr);
  return 0;
 }
 return safe_realloc_mul_2op_(ptr, size1, size2);
}


static inline void *safe_realloc_nofree_muladd2_(void *ptr, size_t size1, size_t size2, size_t size3)
{
 if(!size1 || (!size2 && !size3))
  return realloc(ptr, 0);
 size2 += size3;
 if(size2 < size3)
  return 0;
 return safe_realloc_nofree_mul_2op_(ptr, size1, size2);
}
# 68 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 1 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/private.h" 1
# 39 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/share/private.h"
         FLAC__bool FLAC__stream_encoder_disable_instruction_set(FLAC__StreamEncoder *encoder, FLAC__bool value);
         FLAC__bool FLAC__stream_encoder_disable_constant_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value);
         FLAC__bool FLAC__stream_encoder_disable_fixed_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value);
         FLAC__bool FLAC__stream_encoder_disable_verbatim_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value);
         FLAC__bool FLAC__stream_encoder_set_do_md5(FLAC__StreamEncoder *encoder, FLAC__bool value);
         FLAC__bool FLAC__stream_encoder_get_do_md5(const FLAC__StreamEncoder *encoder);
# 69 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c" 2
# 84 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
typedef struct {
 FLAC__int32 *data[(8u)];
 uint32_t size;
 uint32_t tail;
} verify_input_fifo;

typedef struct {
 const FLAC__byte *data;
 uint32_t capacity;
 uint32_t bytes;
} verify_output;

typedef enum {
 ENCODER_IN_MAGIC = 0,
 ENCODER_IN_METADATA = 1,
 ENCODER_IN_AUDIO = 2
} EncoderStateHint;

static const struct CompressionLevels {
 FLAC__bool do_mid_side_stereo;
 FLAC__bool loose_mid_side_stereo;
 uint32_t max_lpc_order;
 uint32_t qlp_coeff_precision;
 FLAC__bool do_qlp_coeff_prec_search;
 FLAC__bool do_escape_coding;
 FLAC__bool do_exhaustive_model_search;
 uint32_t min_residual_partition_order;
 uint32_t max_residual_partition_order;
 uint32_t rice_parameter_search_dist;
 const char *apodization;
} compression_levels_[] = {
 { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, "tukey(5e-1)" },
 { 1 , 1 , 0, 0, 0, 0, 0, 0, 3, 0, "tukey(5e-1)" },
 { 1 , 0, 0, 0, 0, 0, 0, 0, 3, 0, "tukey(5e-1)" },
 { 0, 0, 6, 0, 0, 0, 0, 0, 4, 0, "tukey(5e-1)" },
 { 1 , 1 , 8, 0, 0, 0, 0, 0, 4, 0, "tukey(5e-1)" },
 { 1 , 0, 8, 0, 0, 0, 0, 0, 5, 0, "tukey(5e-1)" },
 { 1 , 0, 8, 0, 0, 0, 0, 0, 6, 0, "subdivide_tukey(2)" },
 { 1 , 0, 12, 0, 0, 0, 0, 0, 6, 0, "subdivide_tukey(2)" },
 { 1 , 0, 12, 0, 0, 0, 0, 0, 6, 0, "subdivide_tukey(3)" }

};
# 134 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
static void set_defaults_(FLAC__StreamEncoder *encoder);
static void free_(FLAC__StreamEncoder *encoder);
static FLAC__bool resize_buffers_(FLAC__StreamEncoder *encoder, uint32_t new_blocksize);
static FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block);
static FLAC__StreamEncoderWriteStatus write_frame_(FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, uint32_t samples, FLAC__bool is_last_block);
static void update_metadata_(const FLAC__StreamEncoder *encoder);



static FLAC__bool process_frame_(FLAC__StreamEncoder *encoder, FLAC__bool is_last_block);
static FLAC__bool process_subframes_(FLAC__StreamEncoder *encoder);

static FLAC__bool process_subframe_(
 FLAC__StreamEncoder *encoder,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 const FLAC__FrameHeader *frame_header,
 uint32_t subframe_bps,
 const void *integer_signal,
 FLAC__Subframe *subframe[2],
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents[2],
 FLAC__int32 *residual[2],
 uint32_t *best_subframe,
 uint32_t *best_bits
);

static FLAC__bool add_subframe_(
 FLAC__StreamEncoder *encoder,
 uint32_t blocksize,
 uint32_t subframe_bps,
 const FLAC__Subframe *subframe,
 FLAC__BitWriter *frame
);

static uint32_t evaluate_constant_subframe_(
 FLAC__StreamEncoder *encoder,
 const FLAC__int64 signal,
 uint32_t blocksize,
 uint32_t subframe_bps,
 FLAC__Subframe *subframe
);

static uint32_t evaluate_fixed_subframe_(
 FLAC__StreamEncoder *encoder,
 const void *signal,
 FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t raw_bits_per_partition[],
 uint32_t blocksize,
 uint32_t subframe_bps,
 uint32_t order,
 uint32_t rice_parameter_limit,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 FLAC__bool do_escape_coding,
 uint32_t rice_parameter_search_dist,
 FLAC__Subframe *subframe,
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
);


static uint32_t evaluate_lpc_subframe_(
 FLAC__StreamEncoder *encoder,
 const void *signal,
 FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t raw_bits_per_partition[],
 const FLAC__real lp_coeff[],
 uint32_t blocksize,
 uint32_t subframe_bps,
 uint32_t order,
 uint32_t qlp_coeff_precision,
 uint32_t rice_parameter_limit,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 FLAC__bool do_escape_coding,
 uint32_t rice_parameter_search_dist,
 FLAC__Subframe *subframe,
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
);


static uint32_t evaluate_verbatim_subframe_(
 FLAC__StreamEncoder *encoder,
 const void *signal,
 uint32_t blocksize,
 uint32_t subframe_bps,
 FLAC__Subframe *subframe
);

static uint32_t find_best_partition_order_(
 struct FLAC__StreamEncoderPrivate *private_,
 const FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t raw_bits_per_partition[],
 uint32_t residual_samples,
 uint32_t predictor_order,
 uint32_t rice_parameter_limit,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 uint32_t bps,
 FLAC__bool do_escape_coding,
 uint32_t rice_parameter_search_dist,
 FLAC__EntropyCodingMethod *best_ecm
);

static void precompute_partition_info_sums_(
 const FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t residual_samples,
 uint32_t predictor_order,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 uint32_t bps
);

static void precompute_partition_info_escapes_(
 const FLAC__int32 residual[],
 uint32_t raw_bits_per_partition[],
 uint32_t residual_samples,
 uint32_t predictor_order,
 uint32_t min_partition_order,
 uint32_t max_partition_order
);

static FLAC__bool set_partitioned_rice_(



 const FLAC__uint64 abs_residual_partition_sums[],
 const uint32_t raw_bits_per_partition[],
 const uint32_t residual_samples,
 const uint32_t predictor_order,
 const uint32_t rice_parameter_limit,
 const uint32_t rice_parameter_search_dist,
 const uint32_t partition_order,
 const FLAC__bool search_for_escapes,
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents,
 uint32_t *bits
);

static uint32_t get_wasted_bits_(FLAC__int32 signal[], uint32_t samples);
static uint32_t get_wasted_bits_wide_(FLAC__int64 signal_wide[], FLAC__int32 signal[], uint32_t samples);


static void append_to_verify_fifo_(
 verify_input_fifo *fifo,
 const FLAC__int32 * const input[],
 uint32_t input_offset,
 uint32_t channels,
 uint32_t wide_samples
);

static void append_to_verify_fifo_interleaved_(
 verify_input_fifo *fifo,
 const FLAC__int32 input[],
 uint32_t input_offset,
 uint32_t channels,
 uint32_t wide_samples
);

static FLAC__StreamDecoderReadStatus verify_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
static FLAC__StreamDecoderWriteStatus verify_write_callback_(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data);
static void verify_metadata_callback_(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data);
static void verify_error_callback_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);

static FLAC__StreamEncoderReadStatus file_read_callback_(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
static FLAC__StreamEncoderSeekStatus file_seek_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data);
static FLAC__StreamEncoderTellStatus file_tell_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data);
static FLAC__StreamEncoderWriteStatus file_write_callback_(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, uint32_t samples, uint32_t current_frame, void *client_data);
static FILE *get_binary_stdout_(void);
# 313 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
typedef struct FLAC__StreamEncoderPrivate {
 uint32_t input_capacity;
 FLAC__int32 *integer_signal[(8u)];
 FLAC__int32 *integer_signal_mid_side[2];
 FLAC__int64 *integer_signal_33bit_side;

 FLAC__real *real_signal[(8u)];
 FLAC__real *real_signal_mid_side[2];
 FLAC__real *window[32];
 FLAC__real *windowed_signal;

 uint32_t subframe_bps[(8u)];
 uint32_t subframe_bps_mid_side[2];
 FLAC__int32 *residual_workspace[(8u)][2];
 FLAC__int32 *residual_workspace_mid_side[2][2];
 FLAC__Subframe subframe_workspace[(8u)][2];
 FLAC__Subframe subframe_workspace_mid_side[2][2];
 FLAC__Subframe *subframe_workspace_ptr[(8u)][2];
 FLAC__Subframe *subframe_workspace_ptr_mid_side[2][2];
 FLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_workspace[(8u)][2];
 FLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_workspace_mid_side[(8u)][2];
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents_workspace_ptr[(8u)][2];
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents_workspace_ptr_mid_side[(8u)][2];
 uint32_t best_subframe[(8u)];
 uint32_t best_subframe_mid_side[2];
 uint32_t best_subframe_bits[(8u)];
 uint32_t best_subframe_bits_mid_side[2];
 FLAC__uint64 *abs_residual_partition_sums;
 uint32_t *raw_bits_per_partition;
 FLAC__BitWriter *frame;
 uint32_t loose_mid_side_stereo_frames;
 uint32_t loose_mid_side_stereo_frame_count;
 FLAC__ChannelAssignment last_channel_assignment;
 FLAC__StreamMetadata streaminfo;
 FLAC__StreamMetadata_SeekTable *seek_table;
 uint32_t current_sample_number;
 uint32_t current_frame_number;
 FLAC__MD5Context md5context;
 FLAC__CPUInfo cpuinfo;
 void (*local_precompute_partition_info_sums)(const FLAC__int32 residual[], FLAC__uint64 abs_residual_partition_sums[], uint32_t residual_samples, uint32_t predictor_order, uint32_t min_partition_order, uint32_t max_partition_order, uint32_t bps);

 uint32_t (*local_fixed_compute_best_predictor)(const FLAC__int32 data[], uint32_t data_len, float residual_bits_per_sample[(4u)+1]);
 uint32_t (*local_fixed_compute_best_predictor_wide)(const FLAC__int32 data[], uint32_t data_len, float residual_bits_per_sample[(4u)+1]);





 void (*local_lpc_compute_autocorrelation)(const FLAC__real data[], uint32_t data_len, uint32_t lag, double autoc[]);
 void (*local_lpc_compute_residual_from_qlp_coefficients)(const FLAC__int32 *data, uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 residual[]);
 void (*local_lpc_compute_residual_from_qlp_coefficients_64bit)(const FLAC__int32 *data, uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 residual[]);
 void (*local_lpc_compute_residual_from_qlp_coefficients_16bit)(const FLAC__int32 *data, uint32_t data_len, const FLAC__int32 qlp_coeff[], uint32_t order, int lp_quantization, FLAC__int32 residual[]);

 FLAC__bool disable_mmx;
 FLAC__bool disable_sse2;
 FLAC__bool disable_ssse3;
 FLAC__bool disable_sse41;
 FLAC__bool disable_avx2;
 FLAC__bool disable_fma;
 FLAC__bool disable_constant_subframes;
 FLAC__bool disable_fixed_subframes;
 FLAC__bool disable_verbatim_subframes;
 FLAC__bool is_ogg;
 FLAC__StreamEncoderReadCallback read_callback;
 FLAC__StreamEncoderSeekCallback seek_callback;
 FLAC__StreamEncoderTellCallback tell_callback;
 FLAC__StreamEncoderWriteCallback write_callback;
 FLAC__StreamEncoderMetadataCallback metadata_callback;
 FLAC__StreamEncoderProgressCallback progress_callback;
 void *client_data;
 uint32_t first_seekpoint_to_check;
 FILE *file;
 FLAC__uint64 bytes_written;
 FLAC__uint64 samples_written;
 uint32_t frames_written;
 uint32_t total_frames_estimate;

 FLAC__int32 *integer_signal_unaligned[(8u)];
 FLAC__int32 *integer_signal_mid_side_unaligned[2];
 FLAC__int64 *integer_signal_33bit_side_unaligned;

 FLAC__real *real_signal_unaligned[(8u)];
 FLAC__real *real_signal_mid_side_unaligned[2];
 FLAC__real *window_unaligned[32];
 FLAC__real *windowed_signal_unaligned;

 FLAC__int32 *residual_workspace_unaligned[(8u)][2];
 FLAC__int32 *residual_workspace_mid_side_unaligned[2][2];
 FLAC__uint64 *abs_residual_partition_sums_unaligned;
 uint32_t *raw_bits_per_partition_unaligned;





 FLAC__real lp_coeff[(32u)][(32u)];

 FLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_extra[2];



 struct {
  FLAC__StreamDecoder *decoder;
  EncoderStateHint state_hint;
  FLAC__bool needs_magic_hack;
  verify_input_fifo input_fifo;
  verify_output output;
  struct {
   FLAC__uint64 absolute_sample;
   uint32_t frame_number;
   uint32_t channel;
   uint32_t sample;
   FLAC__int32 expected;
   FLAC__int32 got;
  } error_stats;
 } verify;
 FLAC__bool is_being_deleted;
} FLAC__StreamEncoderPrivate;







         const char * const FLAC__StreamEncoderStateString[] = {
 "FLAC__STREAM_ENCODER_OK",
 "FLAC__STREAM_ENCODER_UNINITIALIZED",
 "FLAC__STREAM_ENCODER_OGG_ERROR",
 "FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR",
 "FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA",
 "FLAC__STREAM_ENCODER_CLIENT_ERROR",
 "FLAC__STREAM_ENCODER_IO_ERROR",
 "FLAC__STREAM_ENCODER_FRAMING_ERROR",
 "FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR"
};

         const char * const FLAC__StreamEncoderInitStatusString[] = {
 "FLAC__STREAM_ENCODER_INIT_STATUS_OK",
 "FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR",
 "FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION",
 "FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER",
 "FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE",
 "FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA",
 "FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED"
};

         const char * const FLAC__StreamEncoderReadStatusString[] = {
 "FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE",
 "FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM",
 "FLAC__STREAM_ENCODER_READ_STATUS_ABORT",
 "FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED"
};

         const char * const FLAC__StreamEncoderWriteStatusString[] = {
 "FLAC__STREAM_ENCODER_WRITE_STATUS_OK",
 "FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR"
};

         const char * const FLAC__StreamEncoderSeekStatusString[] = {
 "FLAC__STREAM_ENCODER_SEEK_STATUS_OK",
 "FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR",
 "FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED"
};

         const char * const FLAC__StreamEncoderTellStatusString[] = {
 "FLAC__STREAM_ENCODER_TELL_STATUS_OK",
 "FLAC__STREAM_ENCODER_TELL_STATUS_ERROR",
 "FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED"
};
# 502 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
static const uint32_t OVERREAD_ = 1;






         FLAC__StreamEncoder *FLAC__stream_encoder_new(void)
{
 FLAC__StreamEncoder *encoder;
 uint32_t i;

                               ;

 encoder = calloc(1, sizeof(FLAC__StreamEncoder));
 if(encoder == 0) {
  return 0;
 }

 encoder->protected_ = calloc(1, sizeof(FLAC__StreamEncoderProtected));
 if(encoder->protected_ == 0) {
  free(encoder);
  return 0;
 }

 encoder->private_ = calloc(1, sizeof(FLAC__StreamEncoderPrivate));
 if(encoder->private_ == 0) {
  free(encoder->protected_);
  free(encoder);
  return 0;
 }

 encoder->private_->frame = FLAC__bitwriter_new();
 if(encoder->private_->frame == 0) {
  free(encoder->private_);
  free(encoder->protected_);
  free(encoder);
  return 0;
 }

 encoder->private_->file = 0;

 encoder->protected_->state = FLAC__STREAM_ENCODER_UNINITIALIZED;

 set_defaults_(encoder);

 encoder->private_->is_being_deleted = 0;

 for(i = 0; i < (8u); i++) {
  encoder->private_->subframe_workspace_ptr[i][0] = &encoder->private_->subframe_workspace[i][0];
  encoder->private_->subframe_workspace_ptr[i][1] = &encoder->private_->subframe_workspace[i][1];
 }
 for(i = 0; i < 2; i++) {
  encoder->private_->subframe_workspace_ptr_mid_side[i][0] = &encoder->private_->subframe_workspace_mid_side[i][0];
  encoder->private_->subframe_workspace_ptr_mid_side[i][1] = &encoder->private_->subframe_workspace_mid_side[i][1];
 }
 for(i = 0; i < (8u); i++) {
  encoder->private_->partitioned_rice_contents_workspace_ptr[i][0] = &encoder->private_->partitioned_rice_contents_workspace[i][0];
  encoder->private_->partitioned_rice_contents_workspace_ptr[i][1] = &encoder->private_->partitioned_rice_contents_workspace[i][1];
 }
 for(i = 0; i < 2; i++) {
  encoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][0] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0];
  encoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][1] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1];
 }

 for(i = 0; i < (8u); i++) {
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][0]);
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][1]);
 }
 for(i = 0; i < 2; i++) {
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0]);
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1]);
 }
 for(i = 0; i < 2; i++)
  FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_extra[i]);

 return encoder;
}

         void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder)
{
 uint32_t i;

 if (encoder == ((void*)0))
  return ;

                                       ;
                                     ;
                                            ;

 encoder->private_->is_being_deleted = 1;

 (void)FLAC__stream_encoder_finish(encoder);

 if(0 != encoder->private_->verify.decoder)
  FLAC__stream_decoder_delete(encoder->private_->verify.decoder);

 for(i = 0; i < (8u); i++) {
  FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace[i][0]);
  FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace[i][1]);
 }
 for(i = 0; i < 2; i++) {
  FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0]);
  FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1]);
 }
 for(i = 0; i < 2; i++)
  FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_extra[i]);

 FLAC__bitwriter_delete(encoder->private_->frame);
 free(encoder->private_);
 free(encoder->protected_);
 free(encoder);
}







static FLAC__StreamEncoderInitStatus init_stream_internal_(
 FLAC__StreamEncoder *encoder,
 FLAC__StreamEncoderReadCallback read_callback,
 FLAC__StreamEncoderWriteCallback write_callback,
 FLAC__StreamEncoderSeekCallback seek_callback,
 FLAC__StreamEncoderTellCallback tell_callback,
 FLAC__StreamEncoderMetadataCallback metadata_callback,
 void *client_data,
 FLAC__bool is_ogg
)
{
 uint32_t i;
 FLAC__bool metadata_has_seektable, metadata_has_vorbis_comment, metadata_picture_has_type1, metadata_picture_has_type2;

                           ;

 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;

 if(0 == 0 && is_ogg)
  return FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER;

 if(0 == write_callback || (seek_callback && 0 == tell_callback))
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS;

 if(encoder->protected_->channels == 0 || encoder->protected_->channels > (8u))
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS;

 if(encoder->protected_->channels != 2) {
  encoder->protected_->do_mid_side_stereo = 0;
  encoder->protected_->loose_mid_side_stereo = 0;
 }
 else if(!encoder->protected_->do_mid_side_stereo)
  encoder->protected_->loose_mid_side_stereo = 0;

 if(encoder->protected_->bits_per_sample < (4u) || encoder->protected_->bits_per_sample > (32u))
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE;

 if(!FLAC__format_sample_rate_is_valid(encoder->protected_->sample_rate))
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE;

 if(encoder->protected_->blocksize == 0) {
  if(encoder->protected_->max_lpc_order == 0)
   encoder->protected_->blocksize = 1152;
  else
   encoder->protected_->blocksize = 4096;
 }

 if(encoder->protected_->blocksize < (16u) || encoder->protected_->blocksize > (65535u))
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE;

 if(encoder->protected_->max_lpc_order > (32u))
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER;

 if(encoder->protected_->blocksize < encoder->protected_->max_lpc_order)
  return FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER;

 if(encoder->protected_->qlp_coeff_precision == 0) {
  if(encoder->protected_->bits_per_sample < 16) {


   encoder->protected_->qlp_coeff_precision = (((5u)) >= (2 + encoder->protected_->bits_per_sample / 2) ? ((5u)) : (2 + encoder->protected_->bits_per_sample / 2));
  }
  else if(encoder->protected_->bits_per_sample == 16) {
   if(encoder->protected_->blocksize <= 192)
    encoder->protected_->qlp_coeff_precision = 7;
   else if(encoder->protected_->blocksize <= 384)
    encoder->protected_->qlp_coeff_precision = 8;
   else if(encoder->protected_->blocksize <= 576)
    encoder->protected_->qlp_coeff_precision = 9;
   else if(encoder->protected_->blocksize <= 1152)
    encoder->protected_->qlp_coeff_precision = 10;
   else if(encoder->protected_->blocksize <= 2304)
    encoder->protected_->qlp_coeff_precision = 11;
   else if(encoder->protected_->blocksize <= 4608)
    encoder->protected_->qlp_coeff_precision = 12;
   else
    encoder->protected_->qlp_coeff_precision = 13;
  }
  else {
   if(encoder->protected_->blocksize <= 384)
    encoder->protected_->qlp_coeff_precision = (15u)-2;
   else if(encoder->protected_->blocksize <= 1152)
    encoder->protected_->qlp_coeff_precision = (15u)-1;
   else
    encoder->protected_->qlp_coeff_precision = (15u);
  }
                                                                                         ;
 }
 else if(encoder->protected_->qlp_coeff_precision < (5u) || encoder->protected_->qlp_coeff_precision > (15u))
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION;

 if(encoder->protected_->streamable_subset) {
  if(!FLAC__format_blocksize_is_subset(encoder->protected_->blocksize, encoder->protected_->sample_rate))
   return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
  if(!FLAC__format_sample_rate_is_subset(encoder->protected_->sample_rate))
   return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
  if(
   encoder->protected_->bits_per_sample != 8 &&
   encoder->protected_->bits_per_sample != 12 &&
   encoder->protected_->bits_per_sample != 16 &&
   encoder->protected_->bits_per_sample != 20 &&
   encoder->protected_->bits_per_sample != 24 &&
   encoder->protected_->bits_per_sample != 32
  )
   return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
  if(encoder->protected_->max_residual_partition_order > (8u))
   return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
  if(
   encoder->protected_->sample_rate <= 48000 &&
   (
    encoder->protected_->blocksize > (4608u) ||
    encoder->protected_->max_lpc_order > (12u)
   )
  ) {
   return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
  }
 }

 if(encoder->protected_->max_residual_partition_order >= (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))
  encoder->protected_->max_residual_partition_order = (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN) - 1;
 if(encoder->protected_->min_residual_partition_order >= encoder->protected_->max_residual_partition_order)
  encoder->protected_->min_residual_partition_order = encoder->protected_->max_residual_partition_order;
# 762 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 if(0 != encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0) {
  uint32_t i2;
  for(i2 = 0; i2 < encoder->protected_->num_metadata_blocks; i2++) {
   if(0 != encoder->protected_->metadata[i2] && encoder->protected_->metadata[i2]->type == FLAC__METADATA_TYPE_SEEKTABLE) {
    encoder->private_->seek_table = &encoder->protected_->metadata[i2]->data.seek_table;
    break;
   }
  }
 }


 if(0 == encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0)
  return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
 metadata_has_seektable = 0;
 metadata_has_vorbis_comment = 0;
 metadata_picture_has_type1 = 0;
 metadata_picture_has_type2 = 0;
 for(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {
  const FLAC__StreamMetadata *m = encoder->protected_->metadata[i];
  if(m->type == FLAC__METADATA_TYPE_STREAMINFO)
   return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
  else if(m->type == FLAC__METADATA_TYPE_SEEKTABLE) {
   if(metadata_has_seektable)
    return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
   metadata_has_seektable = 1;
   if(!FLAC__format_seektable_is_legal(&m->data.seek_table))
    return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
  }
  else if(m->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {
   if(metadata_has_vorbis_comment)
    return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
   metadata_has_vorbis_comment = 1;
  }
  else if(m->type == FLAC__METADATA_TYPE_CUESHEET) {
   if(!FLAC__format_cuesheet_is_legal(&m->data.cue_sheet, m->data.cue_sheet.is_cd, 0))
    return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
  }
  else if(m->type == FLAC__METADATA_TYPE_PICTURE) {
   if(!FLAC__format_picture_is_legal(&m->data.picture, 0))
    return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
   if(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD) {
    if(metadata_picture_has_type1)
     return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
    metadata_picture_has_type1 = 1;

    if(
     m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD &&
     (
      (strcmp(m->data.picture.mime_type, "image/png") && strcmp(m->data.picture.mime_type, "-->")) ||
      m->data.picture.width != 32 ||
      m->data.picture.height != 32
     )
    )
     return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
   }
   else if(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON) {
    if(metadata_picture_has_type2)
     return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
    metadata_picture_has_type2 = 1;
   }
  }
 }

 encoder->private_->input_capacity = 0;
 for(i = 0; i < encoder->protected_->channels; i++) {
  encoder->private_->integer_signal_unaligned[i] = encoder->private_->integer_signal[i] = 0;

  encoder->private_->real_signal_unaligned[i] = encoder->private_->real_signal[i] = 0;

 }
 for(i = 0; i < 2; i++) {
  encoder->private_->integer_signal_mid_side_unaligned[i] = encoder->private_->integer_signal_mid_side[i] = 0;

  encoder->private_->real_signal_mid_side_unaligned[i] = encoder->private_->real_signal_mid_side[i] = 0;

 }
 encoder->private_->integer_signal_33bit_side_unaligned = encoder->private_->integer_signal_33bit_side = 0;

 for(i = 0; i < encoder->protected_->num_apodizations; i++)
  encoder->private_->window_unaligned[i] = encoder->private_->window[i] = 0;
 encoder->private_->windowed_signal_unaligned = encoder->private_->windowed_signal = 0;

 for(i = 0; i < encoder->protected_->channels; i++) {
  encoder->private_->residual_workspace_unaligned[i][0] = encoder->private_->residual_workspace[i][0] = 0;
  encoder->private_->residual_workspace_unaligned[i][1] = encoder->private_->residual_workspace[i][1] = 0;
  encoder->private_->best_subframe[i] = 0;
 }
 for(i = 0; i < 2; i++) {
  encoder->private_->residual_workspace_mid_side_unaligned[i][0] = encoder->private_->residual_workspace_mid_side[i][0] = 0;
  encoder->private_->residual_workspace_mid_side_unaligned[i][1] = encoder->private_->residual_workspace_mid_side[i][1] = 0;
  encoder->private_->best_subframe_mid_side[i] = 0;
 }
 encoder->private_->abs_residual_partition_sums_unaligned = encoder->private_->abs_residual_partition_sums = 0;
 encoder->private_->raw_bits_per_partition_unaligned = encoder->private_->raw_bits_per_partition = 0;

 encoder->private_->loose_mid_side_stereo_frames = (uint32_t)((double)encoder->protected_->sample_rate * 0.4 / (double)encoder->protected_->blocksize + 0.5);
# 867 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 if(encoder->private_->loose_mid_side_stereo_frames == 0)
  encoder->private_->loose_mid_side_stereo_frames = 1;
 encoder->private_->loose_mid_side_stereo_frame_count = 0;
 encoder->private_->current_sample_number = 0;
 encoder->private_->current_frame_number = 0;




 FLAC__cpu_info(&encoder->private_->cpuinfo);


 if(encoder->private_->disable_mmx)
  encoder->private_->cpuinfo.x86.mmx = 0;
 if(encoder->private_->disable_sse2)
  encoder->private_->cpuinfo.x86.sse2 = 0;
 if(encoder->private_->disable_ssse3)
  encoder->private_->cpuinfo.x86.ssse3 = 0;
 if(encoder->private_->disable_sse41)
  encoder->private_->cpuinfo.x86.sse41 = 0;
 if(encoder->private_->disable_avx2)
  encoder->private_->cpuinfo.x86.avx2 = 0;
 if(encoder->private_->disable_fma)
  encoder->private_->cpuinfo.x86.fma = 0;


 encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation;

 encoder->private_->local_precompute_partition_info_sums = precompute_partition_info_sums_;
 encoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor;
 encoder->private_->local_fixed_compute_best_predictor_wide = FLAC__fixed_compute_best_predictor_wide;

 encoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients;
 encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide;
 encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients;
# 949 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 if(encoder->private_->cpuinfo.use_asm) {
# 1046 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 }
# 1070 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 encoder->protected_->state = FLAC__STREAM_ENCODER_OK;
# 1080 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 encoder->private_->read_callback = read_callback;
 encoder->private_->write_callback = write_callback;
 encoder->private_->seek_callback = seek_callback;
 encoder->private_->tell_callback = tell_callback;
 encoder->private_->metadata_callback = metadata_callback;
 encoder->private_->client_data = client_data;

 if(!resize_buffers_(encoder, encoder->protected_->blocksize)) {

  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }

 if(!FLAC__bitwriter_init(encoder->private_->frame)) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }




 if(encoder->protected_->verify) {




  encoder->private_->verify.input_fifo.size = encoder->protected_->blocksize+OVERREAD_;
  for(i = 0; i < encoder->protected_->channels; i++) {
   if(0 == (encoder->private_->verify.input_fifo.data[i] = safe_malloc_mul_2op_p(sizeof(FLAC__int32), encoder->private_->verify.input_fifo.size))) {
    encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
    return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
   }
  }
  encoder->private_->verify.input_fifo.tail = 0;




  if(0 == encoder->private_->verify.decoder) {
   encoder->private_->verify.decoder = FLAC__stream_decoder_new();
   if(0 == encoder->private_->verify.decoder) {
    encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
    return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
   }
  }

  if(FLAC__stream_decoder_init_stream(encoder->private_->verify.decoder, verify_read_callback_, 0, 0, 0, 0, verify_write_callback_, verify_metadata_callback_, verify_error_callback_, encoder) != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
   return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
  }
 }
 encoder->private_->verify.error_stats.absolute_sample = 0;
 encoder->private_->verify.error_stats.frame_number = 0;
 encoder->private_->verify.error_stats.channel = 0;
 encoder->private_->verify.error_stats.sample = 0;
 encoder->private_->verify.error_stats.expected = 0;
 encoder->private_->verify.error_stats.got = 0;





 encoder->private_->first_seekpoint_to_check = 0;
 encoder->private_->samples_written = 0;
 encoder->protected_->streaminfo_offset = 0;
 encoder->protected_->seektable_offset = 0;
 encoder->protected_->audio_offset = 0;




 if(encoder->protected_->verify)
  encoder->private_->verify.state_hint = ENCODER_IN_MAGIC;
 if(!FLAC__bitwriter_write_raw_uint32(encoder->private_->frame, FLAC__STREAM_SYNC, FLAC__STREAM_SYNC_LEN)) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }
 if(!write_bitbuffer_(encoder, 0, 0)) {

  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }




 if(encoder->protected_->verify)
  encoder->private_->verify.state_hint = ENCODER_IN_METADATA;
 encoder->private_->streaminfo.type = FLAC__METADATA_TYPE_STREAMINFO;
 encoder->private_->streaminfo.is_last = 0;
 encoder->private_->streaminfo.length = (34u);
 encoder->private_->streaminfo.data.stream_info.min_blocksize = encoder->protected_->blocksize;
 encoder->private_->streaminfo.data.stream_info.max_blocksize = encoder->protected_->blocksize;
 encoder->private_->streaminfo.data.stream_info.min_framesize = 0;
 encoder->private_->streaminfo.data.stream_info.max_framesize = 0;
 encoder->private_->streaminfo.data.stream_info.sample_rate = encoder->protected_->sample_rate;
 encoder->private_->streaminfo.data.stream_info.channels = encoder->protected_->channels;
 encoder->private_->streaminfo.data.stream_info.bits_per_sample = encoder->protected_->bits_per_sample;
 encoder->private_->streaminfo.data.stream_info.total_samples = encoder->protected_->total_samples_estimate;
 memset(encoder->private_->streaminfo.data.stream_info.md5sum, 0, 16);
 if(encoder->protected_->do_md5)
  FLAC__MD5Init(&encoder->private_->md5context);
 if(!FLAC__add_metadata_block(&encoder->private_->streaminfo, encoder->private_->frame)) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }
 if(!write_bitbuffer_(encoder, 0, 0)) {

  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }





 encoder->private_->streaminfo.data.stream_info.min_framesize = (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN) - 1;

 encoder->private_->streaminfo.data.stream_info.total_samples = 0;
# 1207 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 if(!metadata_has_vorbis_comment) {
  FLAC__StreamMetadata vorbis_comment;
  vorbis_comment.type = FLAC__METADATA_TYPE_VORBIS_COMMENT;
  vorbis_comment.is_last = (encoder->protected_->num_metadata_blocks == 0);
  vorbis_comment.length = 4 + 4;
  vorbis_comment.data.vorbis_comment.vendor_string.length = 0;
  vorbis_comment.data.vorbis_comment.vendor_string.entry = 0;
  vorbis_comment.data.vorbis_comment.num_comments = 0;
  vorbis_comment.data.vorbis_comment.comments = 0;
  if(!FLAC__add_metadata_block(&vorbis_comment, encoder->private_->frame)) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
   return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
  }
  if(!write_bitbuffer_(encoder, 0, 0)) {

   return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
  }
 }




 for(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {
  encoder->protected_->metadata[i]->is_last = (i == encoder->protected_->num_metadata_blocks - 1);
  if(!FLAC__add_metadata_block(encoder->protected_->metadata[i], encoder->private_->frame)) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
   return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
  }
  if(!write_bitbuffer_(encoder, 0, 0)) {

   return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
  }
 }


 if(encoder->private_->tell_callback && encoder->private_->tell_callback(encoder, &encoder->protected_->audio_offset, encoder->private_->client_data) == FLAC__STREAM_ENCODER_TELL_STATUS_ERROR) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }

 if(encoder->protected_->verify)
  encoder->private_->verify.state_hint = ENCODER_IN_AUDIO;

 return FLAC__STREAM_ENCODER_INIT_STATUS_OK;
}

         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(
 FLAC__StreamEncoder *encoder,
 FLAC__StreamEncoderWriteCallback write_callback,
 FLAC__StreamEncoderSeekCallback seek_callback,
 FLAC__StreamEncoderTellCallback tell_callback,
 FLAC__StreamEncoderMetadataCallback metadata_callback,
 void *client_data
)
{
 return init_stream_internal_(
  encoder,
                    0,
  write_callback,
  seek_callback,
  tell_callback,
  metadata_callback,
  client_data,
             0
 );
}

         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_stream(
 FLAC__StreamEncoder *encoder,
 FLAC__StreamEncoderReadCallback read_callback,
 FLAC__StreamEncoderWriteCallback write_callback,
 FLAC__StreamEncoderSeekCallback seek_callback,
 FLAC__StreamEncoderTellCallback tell_callback,
 FLAC__StreamEncoderMetadataCallback metadata_callback,
 void *client_data
)
{
 return init_stream_internal_(
  encoder,
  read_callback,
  write_callback,
  seek_callback,
  tell_callback,
  metadata_callback,
  client_data,
             1
 );
}

static FLAC__StreamEncoderInitStatus init_FILE_internal_(
 FLAC__StreamEncoder *encoder,
 FILE *file,
 FLAC__StreamEncoderProgressCallback progress_callback,
 void *client_data,
 FLAC__bool is_ogg
)
{
 FLAC__StreamEncoderInitStatus init_status;

                           ;
                        ;

 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;


 if(file == 0) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_IO_ERROR;
  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }






 if(file == (__getstdout()))
  file = get_binary_stdout_();
# 1334 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 encoder->private_->file = file;

 encoder->private_->progress_callback = progress_callback;
 encoder->private_->bytes_written = 0;
 encoder->private_->samples_written = 0;
 encoder->private_->frames_written = 0;

 init_status = init_stream_internal_(
  encoder,
  encoder->private_->file == (__getstdout())? 0 : is_ogg? file_read_callback_ : 0,
  file_write_callback_,
  encoder->private_->file == (__getstdout())? 0 : file_seek_callback_,
  encoder->private_->file == (__getstdout())? 0 : file_tell_callback_,
                        0,
  client_data,
  is_ogg
 );
 if(init_status != FLAC__STREAM_ENCODER_INIT_STATUS_OK) {

  return init_status;
 }

 {
  uint32_t blocksize = FLAC__stream_encoder_get_blocksize(encoder);

                              ;
  encoder->private_->total_frames_estimate = (uint32_t)((FLAC__stream_encoder_get_total_samples_estimate(encoder) + blocksize - 1) / blocksize);
 }

 return init_status;
}

         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_FILE(
 FLAC__StreamEncoder *encoder,
 FILE *file,
 FLAC__StreamEncoderProgressCallback progress_callback,
 void *client_data
)
{
 return init_FILE_internal_(encoder, file, progress_callback, client_data, 0);
}

         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_FILE(
 FLAC__StreamEncoder *encoder,
 FILE *file,
 FLAC__StreamEncoderProgressCallback progress_callback,
 void *client_data
)
{
 return init_FILE_internal_(encoder, file, progress_callback, client_data, 1);
}

static FLAC__StreamEncoderInitStatus init_file_internal_(
 FLAC__StreamEncoder *encoder,
 const char *filename,
 FLAC__StreamEncoderProgressCallback progress_callback,
 void *client_data,
 FLAC__bool is_ogg
)
{
 FILE *file;

                           ;






 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;

 file = filename? fopen(filename, "w+b") : (__getstdout());

 if(file == 0) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_IO_ERROR;
  return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
 }

 return init_FILE_internal_(encoder, file, progress_callback, client_data, is_ogg);
}

         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_file(
 FLAC__StreamEncoder *encoder,
 const char *filename,
 FLAC__StreamEncoderProgressCallback progress_callback,
 void *client_data
)
{
 return init_file_internal_(encoder, filename, progress_callback, client_data, 0);
}

         FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_file(
 FLAC__StreamEncoder *encoder,
 const char *filename,
 FLAC__StreamEncoderProgressCallback progress_callback,
 void *client_data
)
{
 return init_file_internal_(encoder, filename, progress_callback, client_data, 1);
}

         FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder)
{
 FLAC__bool error = 0;

 if (encoder == ((void*)0))
  return 0;

                                     ;
                                       ;

 if(encoder->protected_->state == FLAC__STREAM_ENCODER_UNINITIALIZED){
  if(encoder->protected_->metadata){
   free(encoder->protected_->metadata);
   encoder->protected_->metadata = 0;
   encoder->protected_->num_metadata_blocks = 0;
  }
  if(0 != encoder->private_->file) {
   if(encoder->private_->file != (__getstdout()))
    fclose(encoder->private_->file);
   encoder->private_->file = 0;
  }
  return 1;
 }

 if(encoder->protected_->state == FLAC__STREAM_ENCODER_OK && !encoder->private_->is_being_deleted) {
  if(encoder->private_->current_sample_number != 0) {
   encoder->protected_->blocksize = encoder->private_->current_sample_number;
   if(!resize_buffers_(encoder, encoder->protected_->blocksize)) {

    return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
   }
   if(!process_frame_(encoder, 1))
    error = 1;
  }
 }

 if(encoder->protected_->do_md5)
  FLAC__MD5Final(encoder->private_->streaminfo.data.stream_info.md5sum, &encoder->private_->md5context);

 if(!encoder->private_->is_being_deleted) {
  if(encoder->protected_->state == FLAC__STREAM_ENCODER_OK) {
   if(encoder->private_->seek_callback) {





    update_metadata_(encoder);


    if(encoder->protected_->state != FLAC__STREAM_ENCODER_OK)
     error = 1;
   }
   if(encoder->private_->metadata_callback)
    encoder->private_->metadata_callback(encoder, &encoder->private_->streaminfo, encoder->private_->client_data);
  }

  if(encoder->protected_->verify && 0 != encoder->private_->verify.decoder && !FLAC__stream_decoder_finish(encoder->private_->verify.decoder)) {
   if(!error)
    encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA;
   error = 1;
  }
 }

 if(0 != encoder->private_->file) {
  if(encoder->private_->file != (__getstdout()))
   fclose(encoder->private_->file);
  encoder->private_->file = 0;
 }






 free_(encoder);
 set_defaults_(encoder);

 if(!error)
  encoder->protected_->state = FLAC__STREAM_ENCODER_UNINITIALIZED;

 return !error;
}

         FLAC__bool FLAC__stream_encoder_set_ogg_serial_number(FLAC__StreamEncoder *encoder, long value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;





 (void)value;
 return 0;

}

         FLAC__bool FLAC__stream_encoder_set_verify(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;

 encoder->protected_->verify = value;

 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_streamable_subset(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->streamable_subset = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_do_md5(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->do_md5 = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->channels = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->bits_per_sample = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->sample_rate = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder, uint32_t value)
{
 FLAC__bool ok = 1;
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 if(value >= sizeof(compression_levels_)/sizeof(compression_levels_[0]))
  value = sizeof(compression_levels_)/sizeof(compression_levels_[0]) - 1;
 ok &= FLAC__stream_encoder_set_do_mid_side_stereo (encoder, compression_levels_[value].do_mid_side_stereo);
 ok &= FLAC__stream_encoder_set_loose_mid_side_stereo (encoder, compression_levels_[value].loose_mid_side_stereo);


 ok &= FLAC__stream_encoder_set_apodization (encoder, compression_levels_[value].apodization);







 ok &= FLAC__stream_encoder_set_max_lpc_order (encoder, compression_levels_[value].max_lpc_order);
 ok &= FLAC__stream_encoder_set_qlp_coeff_precision (encoder, compression_levels_[value].qlp_coeff_precision);
 ok &= FLAC__stream_encoder_set_do_qlp_coeff_prec_search (encoder, compression_levels_[value].do_qlp_coeff_prec_search);
 ok &= FLAC__stream_encoder_set_do_escape_coding (encoder, compression_levels_[value].do_escape_coding);
 ok &= FLAC__stream_encoder_set_do_exhaustive_model_search (encoder, compression_levels_[value].do_exhaustive_model_search);
 ok &= FLAC__stream_encoder_set_min_residual_partition_order(encoder, compression_levels_[value].min_residual_partition_order);
 ok &= FLAC__stream_encoder_set_max_residual_partition_order(encoder, compression_levels_[value].max_residual_partition_order);
 ok &= FLAC__stream_encoder_set_rice_parameter_search_dist (encoder, compression_levels_[value].rice_parameter_search_dist);
 return ok;
}

         FLAC__bool FLAC__stream_encoder_set_blocksize(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->blocksize = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_do_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->do_mid_side_stereo = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_loose_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->loose_mid_side_stereo = value;
 return 1;
}


         FLAC__bool FLAC__stream_encoder_set_apodization(FLAC__StreamEncoder *encoder, const char *specification)
{
                           ;
                                     ;
                                       ;
                                 ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;



 encoder->protected_->num_apodizations = 0;
 while(1) {
  const char *s = strchr(specification, ';');
  const size_t n = s? (size_t)(s - specification) : strlen(specification);
  if (n==8 && 0 == strncmp("bartlett" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT;
  else if(n==13 && 0 == strncmp("bartlett_hann", specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT_HANN;
  else if(n==8 && 0 == strncmp("blackman" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN;
  else if(n==26 && 0 == strncmp("blackman_harris_4term_92db", specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE;
  else if(n==6 && 0 == strncmp("connes" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_CONNES;
  else if(n==7 && 0 == strncmp("flattop" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_FLATTOP;
  else if(n>7 && 0 == strncmp("gauss(" , specification, 6)) {
   FLAC__real stddev = (FLAC__real)strtod(specification+6, 0);
   if (stddev > 0.0 && stddev <= 0.5) {
    encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.gauss.stddev = stddev;
    encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_GAUSS;
   }
  }
  else if(n==7 && 0 == strncmp("hamming" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HAMMING;
  else if(n==4 && 0 == strncmp("hann" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HANN;
  else if(n==13 && 0 == strncmp("kaiser_bessel", specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_KAISER_BESSEL;
  else if(n==7 && 0 == strncmp("nuttall" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_NUTTALL;
  else if(n==9 && 0 == strncmp("rectangle" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_RECTANGLE;
  else if(n==8 && 0 == strncmp("triangle" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TRIANGLE;
  else if(n>7 && 0 == strncmp("tukey(" , specification, 6)) {
   FLAC__real p = (FLAC__real)strtod(specification+6, 0);
   if (p >= 0.0 && p <= 1.0) {
    encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = p;
    encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;
   }
  }
  else if(n>15 && 0 == strncmp("partial_tukey(", specification, 14)) {
   FLAC__int32 tukey_parts = (FLAC__int32)strtod(specification+14, 0);
   const char *si_1 = strchr(specification, '/');
   FLAC__real overlap = si_1?(((FLAC__real)strtod(si_1+1, 0)) <= (0.99f) ? ((FLAC__real)strtod(si_1+1, 0)) : (0.99f)):0.1f;
   FLAC__real overlap_units = 1.0f/(1.0f - overlap) - 1.0f;
   const char *si_2 = strchr((si_1?(si_1+1):specification), '/');
   FLAC__real tukey_p = si_2?(FLAC__real)strtod(si_2+1, 0):0.2f;

   if (tukey_parts <= 1) {
    encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = tukey_p;
    encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;
   }else if (encoder->protected_->num_apodizations + tukey_parts < 32){
    FLAC__int32 m;
    for(m = 0; m < tukey_parts; m++){
     encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.p = tukey_p;
     encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.start = m/(tukey_parts+overlap_units);
     encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.end = (m+1+overlap_units)/(tukey_parts+overlap_units);
     encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_PARTIAL_TUKEY;
    }
   }
  }
  else if(n>16 && 0 == strncmp("punchout_tukey(", specification, 15)) {
   FLAC__int32 tukey_parts = (FLAC__int32)strtod(specification+15, 0);
   const char *si_1 = strchr(specification, '/');
   FLAC__real overlap = si_1?(((FLAC__real)strtod(si_1+1, 0)) <= (0.99f) ? ((FLAC__real)strtod(si_1+1, 0)) : (0.99f)):0.2f;
   FLAC__real overlap_units = 1.0f/(1.0f - overlap) - 1.0f;
   const char *si_2 = strchr((si_1?(si_1+1):specification), '/');
   FLAC__real tukey_p = si_2?(FLAC__real)strtod(si_2+1, 0):0.2f;

   if (tukey_parts <= 1) {
    encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = tukey_p;
    encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;
   }else if (encoder->protected_->num_apodizations + tukey_parts < 32){
    FLAC__int32 m;
    for(m = 0; m < tukey_parts; m++){
     encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.p = tukey_p;
     encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.start = m/(tukey_parts+overlap_units);
     encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.end = (m+1+overlap_units)/(tukey_parts+overlap_units);
     encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_PUNCHOUT_TUKEY;
    }
   }
  }
  else if(n>17 && 0 == strncmp("subdivide_tukey(", specification, 16)){
   FLAC__int32 parts = (FLAC__int32)strtod(specification+16, 0);
   if(parts > 1){
    const char *si_1 = strchr(specification, '/');
    FLAC__real p = si_1?(FLAC__real)strtod(si_1+1, 0):5e-1;
    if(p > 1)
     p = 1;
    else if(p < 0)
     p = 0;
    encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.subdivide_tukey.parts = parts;
    encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.subdivide_tukey.p = p/parts;
    encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_SUBDIVIDE_TUKEY;
   }
  }
  else if(n==5 && 0 == strncmp("welch" , specification, n))
   encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_WELCH;
  if (encoder->protected_->num_apodizations == 32)
   break;
  if (s)
   specification = s+1;
  else
   break;
 }
 if(encoder->protected_->num_apodizations == 0) {
  encoder->protected_->num_apodizations = 1;
  encoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;
  encoder->protected_->apodizations[0].parameters.tukey.p = 0.5;
 }

 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_max_lpc_order(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->max_lpc_order = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_qlp_coeff_precision(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->qlp_coeff_precision = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_do_qlp_coeff_prec_search(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->do_qlp_coeff_prec_search = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_do_escape_coding(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;






 (void)value;

 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_do_exhaustive_model_search(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->do_exhaustive_model_search = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_min_residual_partition_order(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->min_residual_partition_order = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_max_residual_partition_order(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->max_residual_partition_order = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_rice_parameter_search_dist(FLAC__StreamEncoder *encoder, uint32_t value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;




 (void)value;

 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_total_samples_estimate(FLAC__StreamEncoder *encoder, FLAC__uint64 value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 value = ((value) <= ((1ULL << FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN) - 1) ? (value) : ((1ULL << FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN) - 1));
 encoder->protected_->total_samples_estimate = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder, FLAC__StreamMetadata **metadata, uint32_t num_blocks)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 if(0 == metadata)
  num_blocks = 0;
 if(0 == num_blocks)
  metadata = 0;

 if(encoder->protected_->metadata) {
  free(encoder->protected_->metadata);
  encoder->protected_->metadata = 0;
  encoder->protected_->num_metadata_blocks = 0;
 }
 if(num_blocks) {
  FLAC__StreamMetadata **m;
  if(0 == (m = safe_malloc_mul_2op_p(sizeof(m[0]), num_blocks)))
   return 0;
  memcpy(m, metadata, sizeof(m[0]) * num_blocks);
  encoder->protected_->metadata = m;
  encoder->protected_->num_metadata_blocks = num_blocks;
 }




 return 1;
}

         FLAC__bool FLAC__stream_encoder_set_limit_min_bitrate(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->protected_->limit_min_bitrate = value;
 return 1;
}





         FLAC__bool FLAC__stream_encoder_disable_instruction_set(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->private_->disable_mmx = value & 1;
 encoder->private_->disable_sse2 = value & 2;
 encoder->private_->disable_ssse3 = value & 4;
 encoder->private_->disable_sse41 = value & 8;
 encoder->private_->disable_avx2 = value & 16;
 encoder->private_->disable_fma = value & 32;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_disable_constant_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->private_->disable_constant_subframes = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_disable_fixed_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->private_->disable_fixed_subframes = value;
 return 1;
}

         FLAC__bool FLAC__stream_encoder_disable_verbatim_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
  return 0;
 encoder->private_->disable_verbatim_subframes = value;
 return 1;
}

         FLAC__StreamEncoderState FLAC__stream_encoder_get_state(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->state;
}

         FLAC__StreamDecoderState FLAC__stream_encoder_get_verify_decoder_state(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->verify)
  return FLAC__stream_decoder_get_state(encoder->private_->verify.decoder);
 else
  return FLAC__STREAM_DECODER_UNINITIALIZED;
}

         const char *FLAC__stream_encoder_get_resolved_state_string(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 if(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR)
  return FLAC__StreamEncoderStateString[encoder->protected_->state];
 else
  return FLAC__stream_decoder_get_resolved_state_string(encoder->private_->verify.decoder);
}

         void FLAC__stream_encoder_get_verify_decoder_error_stats(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_sample, uint32_t *frame_number, uint32_t *channel, uint32_t *sample, FLAC__int32 *expected, FLAC__int32 *got)
{
                           ;
                                     ;
                                       ;
 if(0 != absolute_sample)
  *absolute_sample = encoder->private_->verify.error_stats.absolute_sample;
 if(0 != frame_number)
  *frame_number = encoder->private_->verify.error_stats.frame_number;
 if(0 != channel)
  *channel = encoder->private_->verify.error_stats.channel;
 if(0 != sample)
  *sample = encoder->private_->verify.error_stats.sample;
 if(0 != expected)
  *expected = encoder->private_->verify.error_stats.expected;
 if(0 != got)
  *got = encoder->private_->verify.error_stats.got;
}

         FLAC__bool FLAC__stream_encoder_get_verify(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->verify;
}

         FLAC__bool FLAC__stream_encoder_get_streamable_subset(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->streamable_subset;
}

         FLAC__bool FLAC__stream_encoder_get_do_md5(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->do_md5;
}

         uint32_t FLAC__stream_encoder_get_channels(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->channels;
}

         uint32_t FLAC__stream_encoder_get_bits_per_sample(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->bits_per_sample;
}

         uint32_t FLAC__stream_encoder_get_sample_rate(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->sample_rate;
}

         uint32_t FLAC__stream_encoder_get_blocksize(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->blocksize;
}

         FLAC__bool FLAC__stream_encoder_get_do_mid_side_stereo(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->do_mid_side_stereo;
}

         FLAC__bool FLAC__stream_encoder_get_loose_mid_side_stereo(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->loose_mid_side_stereo;
}

         uint32_t FLAC__stream_encoder_get_max_lpc_order(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->max_lpc_order;
}

         uint32_t FLAC__stream_encoder_get_qlp_coeff_precision(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->qlp_coeff_precision;
}

         FLAC__bool FLAC__stream_encoder_get_do_qlp_coeff_prec_search(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->do_qlp_coeff_prec_search;
}

         FLAC__bool FLAC__stream_encoder_get_do_escape_coding(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->do_escape_coding;
}

         FLAC__bool FLAC__stream_encoder_get_do_exhaustive_model_search(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->do_exhaustive_model_search;
}

         uint32_t FLAC__stream_encoder_get_min_residual_partition_order(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->min_residual_partition_order;
}

         uint32_t FLAC__stream_encoder_get_max_residual_partition_order(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->max_residual_partition_order;
}

         uint32_t FLAC__stream_encoder_get_rice_parameter_search_dist(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->rice_parameter_search_dist;
}

         FLAC__uint64 FLAC__stream_encoder_get_total_samples_estimate(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->total_samples_estimate;
}

         FLAC__bool FLAC__stream_encoder_get_limit_min_bitrate(const FLAC__StreamEncoder *encoder)
{
                           ;
                                     ;
                                       ;
 return encoder->protected_->limit_min_bitrate;
}

         FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], uint32_t samples)
{
 uint32_t i, j = 0, k = 0, channel;
 const uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize, bps = encoder->protected_->bits_per_sample;
 const FLAC__int32 sample_max = 2147483647 >> (32 - encoder->protected_->bits_per_sample);
 const FLAC__int32 sample_min = (-2147483647-1) >> (32 - encoder->protected_->bits_per_sample);

                           ;
                                     ;
                                       ;

 if(encoder->protected_->state != FLAC__STREAM_ENCODER_OK)
  return 0;

 do {
  const uint32_t n = ((blocksize+OVERREAD_-encoder->private_->current_sample_number) <= (samples-j) ? (blocksize+OVERREAD_-encoder->private_->current_sample_number) : (samples-j));

  if(encoder->protected_->verify)
   append_to_verify_fifo_(&encoder->private_->verify.input_fifo, buffer, j, channels, n);

  for(channel = 0; channel < channels; channel++) {
   for(i = encoder->private_->current_sample_number, k = j; i <= blocksize && k < samples; i++, k++) {
    if(buffer[channel][k] < sample_min || buffer[channel][k] > sample_max){
     encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
     return 0;
    }
   }
   if (buffer[channel] == ((void*)0)) {
    return 0;
   }
   memcpy(&encoder->private_->integer_signal[channel][encoder->private_->current_sample_number], &buffer[channel][j], sizeof(buffer[channel][0]) * n);
  }

  if(encoder->protected_->do_mid_side_stereo) {
                              ;

   if(bps < 32)
    for(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {
     encoder->private_->integer_signal_mid_side[1][i] = buffer[0][j] - buffer[1][j];
     encoder->private_->integer_signal_mid_side[0][i] = (buffer[0][j] + buffer[1][j]) >> 1;
    }
   else
    for(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {
     encoder->private_->integer_signal_33bit_side[i] = (FLAC__int64)buffer[0][j] - (FLAC__int64)buffer[1][j];
     encoder->private_->integer_signal_mid_side[0][i] = ((FLAC__int64)buffer[0][j] + (FLAC__int64)buffer[1][j]) >> 1;
    }
  }
  else
   j += n;

  encoder->private_->current_sample_number += n;


  if(encoder->private_->current_sample_number > blocksize) {
                                                                                ;
                               ;
   if(!process_frame_(encoder, 0))
    return 0;

   for(channel = 0; channel < channels; channel++)
    encoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];
   if(encoder->protected_->do_mid_side_stereo) {
    encoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];
    if(bps < 32)
     encoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];
    else
     encoder->private_->integer_signal_33bit_side[0] = encoder->private_->integer_signal_33bit_side[blocksize];
   }
   encoder->private_->current_sample_number = 1;
  }
 } while(j < samples);

 return 1;
}

         FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder, const FLAC__int32 buffer[], uint32_t samples)
{
 uint32_t i, j, k, channel;
 const uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize, bps = encoder->protected_->bits_per_sample;
 const FLAC__int32 sample_max = 2147483647 >> (32 - encoder->protected_->bits_per_sample);
 const FLAC__int32 sample_min = (-2147483647-1) >> (32 - encoder->protected_->bits_per_sample);

                           ;
                                     ;
                                       ;

 if(encoder->protected_->state != FLAC__STREAM_ENCODER_OK)
  return 0;

 j = k = 0;




 if(encoder->protected_->do_mid_side_stereo && channels == 2) {



  do {
   if(encoder->protected_->verify)
    append_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, ((blocksize+OVERREAD_-encoder->private_->current_sample_number) <= (samples-j) ? (blocksize+OVERREAD_-encoder->private_->current_sample_number) : (samples-j)));


   for(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {
    if(buffer[k] < sample_min || buffer[k] > sample_max ||
       buffer[k+1] < sample_min || buffer[k+1] > sample_max){
     encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
     return 0;
    }
    encoder->private_->integer_signal[0][i] = buffer[k++];
    encoder->private_->integer_signal[1][i] = buffer[k++];
    if(bps < 32){
     encoder->private_->integer_signal_mid_side[1][i] = encoder->private_->integer_signal[0][i] - encoder->private_->integer_signal[1][i];
     encoder->private_->integer_signal_mid_side[0][i] = (encoder->private_->integer_signal[0][i] + encoder->private_->integer_signal[1][i]) >> 1;
    }
    else {
     encoder->private_->integer_signal_33bit_side[i] = (FLAC__int64)encoder->private_->integer_signal[0][i] - (FLAC__int64)encoder->private_->integer_signal[1][i];
     encoder->private_->integer_signal_mid_side[0][i] = ((FLAC__int64)encoder->private_->integer_signal[0][i] + (FLAC__int64)encoder->private_->integer_signal[1][i]) >> 1;
    }
   }
   encoder->private_->current_sample_number = i;

   if(i > blocksize) {
    if(!process_frame_(encoder, 0))
     return 0;

                                          ;
                                ;
    encoder->private_->integer_signal[0][0] = encoder->private_->integer_signal[0][blocksize];
    encoder->private_->integer_signal[1][0] = encoder->private_->integer_signal[1][blocksize];
    encoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];
    if(bps < 32)
     encoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];
    else
     encoder->private_->integer_signal_33bit_side[0] = encoder->private_->integer_signal_33bit_side[blocksize];
    encoder->private_->current_sample_number = 1;
   }
  } while(j < samples);
 }
 else {



  do {
   if(encoder->protected_->verify)
    append_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, ((blocksize+OVERREAD_-encoder->private_->current_sample_number) <= (samples-j) ? (blocksize+OVERREAD_-encoder->private_->current_sample_number) : (samples-j)));


   for(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {
    for(channel = 0; channel < channels; channel++){
     if(buffer[k] < sample_min || buffer[k] > sample_max){
      encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
      return 0;
     }
     encoder->private_->integer_signal[channel][i] = buffer[k++];
    }
   }
   encoder->private_->current_sample_number = i;

   if(i > blocksize) {
    if(!process_frame_(encoder, 0))
     return 0;

                                          ;
                                ;
    for(channel = 0; channel < channels; channel++)
     encoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];
    encoder->private_->current_sample_number = 1;
   }
  } while(j < samples);
 }

 return 1;
}







void set_defaults_(FLAC__StreamEncoder *encoder)
{
                           ;




 encoder->protected_->verify = 0;

 encoder->protected_->streamable_subset = 1;
 encoder->protected_->do_md5 = 1;
 encoder->protected_->do_mid_side_stereo = 0;
 encoder->protected_->loose_mid_side_stereo = 0;
 encoder->protected_->channels = 2;
 encoder->protected_->bits_per_sample = 16;
 encoder->protected_->sample_rate = 44100;
 encoder->protected_->blocksize = 0;

 encoder->protected_->num_apodizations = 1;
 encoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;
 encoder->protected_->apodizations[0].parameters.tukey.p = 0.5;

 encoder->protected_->max_lpc_order = 0;
 encoder->protected_->qlp_coeff_precision = 0;
 encoder->protected_->do_qlp_coeff_prec_search = 0;
 encoder->protected_->do_exhaustive_model_search = 0;
 encoder->protected_->do_escape_coding = 0;
 encoder->protected_->min_residual_partition_order = 0;
 encoder->protected_->max_residual_partition_order = 0;
 encoder->protected_->rice_parameter_search_dist = 0;
 encoder->protected_->total_samples_estimate = 0;
 encoder->protected_->limit_min_bitrate = 0;
 encoder->protected_->metadata = 0;
 encoder->protected_->num_metadata_blocks = 0;

 encoder->private_->seek_table = 0;
 encoder->private_->disable_mmx = 0;
 encoder->private_->disable_sse2 = 0;
 encoder->private_->disable_ssse3 = 0;
 encoder->private_->disable_sse41 = 0;
 encoder->private_->disable_avx2 = 0;
 encoder->private_->disable_constant_subframes = 0;
 encoder->private_->disable_fixed_subframes = 0;
 encoder->private_->disable_verbatim_subframes = 0;
 encoder->private_->is_ogg = 0;
 encoder->private_->read_callback = 0;
 encoder->private_->write_callback = 0;
 encoder->private_->seek_callback = 0;
 encoder->private_->tell_callback = 0;
 encoder->private_->metadata_callback = 0;
 encoder->private_->progress_callback = 0;
 encoder->private_->client_data = 0;





 FLAC__stream_encoder_set_compression_level(encoder, 5);
}

void free_(FLAC__StreamEncoder *encoder)
{
 uint32_t i, channel;

                           ;
 if(encoder->protected_->metadata) {
  free(encoder->protected_->metadata);
  encoder->protected_->metadata = 0;
  encoder->protected_->num_metadata_blocks = 0;
 }
 for(i = 0; i < encoder->protected_->channels; i++) {
  if(0 != encoder->private_->integer_signal_unaligned[i]) {
   free(encoder->private_->integer_signal_unaligned[i]);
   encoder->private_->integer_signal_unaligned[i] = 0;
  }

  if(0 != encoder->private_->real_signal_unaligned[i]) {
   free(encoder->private_->real_signal_unaligned[i]);
   encoder->private_->real_signal_unaligned[i] = 0;
  }

 }
 for(i = 0; i < 2; i++) {
  if(0 != encoder->private_->integer_signal_mid_side_unaligned[i]) {
   free(encoder->private_->integer_signal_mid_side_unaligned[i]);
   encoder->private_->integer_signal_mid_side_unaligned[i] = 0;
  }

  if(0 != encoder->private_->real_signal_mid_side_unaligned[i]) {
   free(encoder->private_->real_signal_mid_side_unaligned[i]);
   encoder->private_->real_signal_mid_side_unaligned[i] = 0;
  }

 }
 if(0 != encoder->private_->integer_signal_33bit_side_unaligned){
  free(encoder->private_->integer_signal_33bit_side_unaligned);
  encoder->private_->integer_signal_33bit_side_unaligned = 0;
 }

 for(i = 0; i < encoder->protected_->num_apodizations; i++) {
  if(0 != encoder->private_->window_unaligned[i]) {
   free(encoder->private_->window_unaligned[i]);
   encoder->private_->window_unaligned[i] = 0;
  }
 }
 if(0 != encoder->private_->windowed_signal_unaligned) {
  free(encoder->private_->windowed_signal_unaligned);
  encoder->private_->windowed_signal_unaligned = 0;
 }

 for(channel = 0; channel < encoder->protected_->channels; channel++) {
  for(i = 0; i < 2; i++) {
   if(0 != encoder->private_->residual_workspace_unaligned[channel][i]) {
    free(encoder->private_->residual_workspace_unaligned[channel][i]);
    encoder->private_->residual_workspace_unaligned[channel][i] = 0;
   }
  }
 }
 for(channel = 0; channel < 2; channel++) {
  for(i = 0; i < 2; i++) {
   if(0 != encoder->private_->residual_workspace_mid_side_unaligned[channel][i]) {
    free(encoder->private_->residual_workspace_mid_side_unaligned[channel][i]);
    encoder->private_->residual_workspace_mid_side_unaligned[channel][i] = 0;
   }
  }
 }
 if(0 != encoder->private_->abs_residual_partition_sums_unaligned) {
  free(encoder->private_->abs_residual_partition_sums_unaligned);
  encoder->private_->abs_residual_partition_sums_unaligned = 0;
 }
 if(0 != encoder->private_->raw_bits_per_partition_unaligned) {
  free(encoder->private_->raw_bits_per_partition_unaligned);
  encoder->private_->raw_bits_per_partition_unaligned = 0;
 }
 if(encoder->protected_->verify) {
  for(i = 0; i < encoder->protected_->channels; i++) {
   if(0 != encoder->private_->verify.input_fifo.data[i]) {
    free(encoder->private_->verify.input_fifo.data[i]);
    encoder->private_->verify.input_fifo.data[i] = 0;
   }
  }
 }
 FLAC__bitwriter_free(encoder->private_->frame);
}

FLAC__bool resize_buffers_(FLAC__StreamEncoder *encoder, uint32_t new_blocksize)
{
 FLAC__bool ok;
 uint32_t i, channel;

                                ;
                                                                    ;

 ok = 1;


 if(new_blocksize > encoder->private_->input_capacity) {







  for(i = 0; ok && i < encoder->protected_->channels; i++) {
   ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize+4+OVERREAD_, &encoder->private_->integer_signal_unaligned[i], &encoder->private_->integer_signal[i]);
   if(ok) {
    memset(encoder->private_->integer_signal[i], 0, sizeof(FLAC__int32)*4);
    encoder->private_->integer_signal[i] += 4;
   }
  }
  for(i = 0; ok && i < 2; i++) {
   ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize+4+OVERREAD_, &encoder->private_->integer_signal_mid_side_unaligned[i], &encoder->private_->integer_signal_mid_side[i]);
   if(ok) {
    memset(encoder->private_->integer_signal_mid_side[i], 0, sizeof(FLAC__int32)*4);
    encoder->private_->integer_signal_mid_side[i] += 4;
   }
  }
  ok = ok && FLAC__memory_alloc_aligned_int64_array(new_blocksize+4+OVERREAD_, &encoder->private_->integer_signal_33bit_side_unaligned, &encoder->private_->integer_signal_33bit_side);

  if(ok && encoder->protected_->max_lpc_order > 0) {
   for(i = 0; ok && i < encoder->protected_->num_apodizations; i++)
    ok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize, &encoder->private_->window_unaligned[i], &encoder->private_->window[i]);
   ok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize, &encoder->private_->windowed_signal_unaligned, &encoder->private_->windowed_signal);
  }

  for(channel = 0; ok && channel < encoder->protected_->channels; channel++) {
   for(i = 0; ok && i < 2; i++) {
    ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize, &encoder->private_->residual_workspace_unaligned[channel][i], &encoder->private_->residual_workspace[channel][i]);
   }
  }


  for(channel = 0; ok && channel < encoder->protected_->channels; channel++) {
   for(i = 0; ok && i < 2; i++) {
    ok = ok && FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(&encoder->private_->partitioned_rice_contents_workspace[channel][i], encoder->protected_->max_residual_partition_order);
    ok = ok && FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(&encoder->private_->partitioned_rice_contents_workspace[channel][i], encoder->protected_->max_residual_partition_order);
   }
  }

  for(channel = 0; ok && channel < 2; channel++) {
   for(i = 0; ok && i < 2; i++) {
    ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize, &encoder->private_->residual_workspace_mid_side_unaligned[channel][i], &encoder->private_->residual_workspace_mid_side[channel][i]);
   }
  }

  for(channel = 0; ok && channel < 2; channel++) {
   for(i = 0; ok && i < 2; i++) {
    ok = ok && FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(&encoder->private_->partitioned_rice_contents_workspace_mid_side[channel][i], encoder->protected_->max_residual_partition_order);
   }
  }

  for(i = 0; ok && i < 2; i++) {
   ok = ok && FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(&encoder->private_->partitioned_rice_contents_extra[i], encoder->protected_->max_residual_partition_order);
  }




  ok = ok && FLAC__memory_alloc_aligned_uint64_array(new_blocksize * 2, &encoder->private_->abs_residual_partition_sums_unaligned, &encoder->private_->abs_residual_partition_sums);
  if(encoder->protected_->do_escape_coding)
   ok = ok && FLAC__memory_alloc_aligned_uint32_array(new_blocksize * 2, &encoder->private_->raw_bits_per_partition_unaligned, &encoder->private_->raw_bits_per_partition);
}
 if(ok)
  encoder->private_->input_capacity = new_blocksize;
 else {
  encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
  return ok;
 }




 if(encoder->protected_->max_lpc_order > 0 && new_blocksize > 1) {
  for(i = 0; i < encoder->protected_->num_apodizations; i++) {
   switch(encoder->protected_->apodizations[i].type) {
    case FLAC__APODIZATION_BARTLETT:
     FLAC__window_bartlett(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_BARTLETT_HANN:
     FLAC__window_bartlett_hann(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_BLACKMAN:
     FLAC__window_blackman(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE:
     FLAC__window_blackman_harris_4term_92db_sidelobe(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_CONNES:
     FLAC__window_connes(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_FLATTOP:
     FLAC__window_flattop(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_GAUSS:
     FLAC__window_gauss(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.gauss.stddev);
     break;
    case FLAC__APODIZATION_HAMMING:
     FLAC__window_hamming(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_HANN:
     FLAC__window_hann(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_KAISER_BESSEL:
     FLAC__window_kaiser_bessel(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_NUTTALL:
     FLAC__window_nuttall(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_RECTANGLE:
     FLAC__window_rectangle(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_TRIANGLE:
     FLAC__window_triangle(encoder->private_->window[i], new_blocksize);
     break;
    case FLAC__APODIZATION_TUKEY:
     FLAC__window_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.tukey.p);
     break;
    case FLAC__APODIZATION_PARTIAL_TUKEY:
     FLAC__window_partial_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.multiple_tukey.p, encoder->protected_->apodizations[i].parameters.multiple_tukey.start, encoder->protected_->apodizations[i].parameters.multiple_tukey.end);
     break;
    case FLAC__APODIZATION_PUNCHOUT_TUKEY:
     FLAC__window_punchout_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.multiple_tukey.p, encoder->protected_->apodizations[i].parameters.multiple_tukey.start, encoder->protected_->apodizations[i].parameters.multiple_tukey.end);
     break;
    case FLAC__APODIZATION_SUBDIVIDE_TUKEY:
     FLAC__window_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.tukey.p);
     break;
    case FLAC__APODIZATION_WELCH:
     FLAC__window_welch(encoder->private_->window[i], new_blocksize);
     break;
    default:
                    ;

     FLAC__window_hann(encoder->private_->window[i], new_blocksize);
     break;
   }
  }
 }
 if (new_blocksize <= (32u)) {


  encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation;
 }


 return 1;
}

FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block)
{
 const FLAC__byte *buffer;
 size_t bytes;

                                                                        ;

 if(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
  return 0;
 }

 if(encoder->protected_->verify) {
  encoder->private_->verify.output.data = buffer;
  encoder->private_->verify.output.bytes = bytes;
  if(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {
   encoder->private_->verify.needs_magic_hack = 1;
  }
  else {
   if(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)
       || (!is_last_block
        && (FLAC__stream_encoder_get_verify_decoder_state(encoder) == FLAC__STREAM_DECODER_END_OF_STREAM))
       || encoder->protected_->state == FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR ) {
    FLAC__bitwriter_release_buffer(encoder->private_->frame);
    FLAC__bitwriter_clear(encoder->private_->frame);
    if(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)
     encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
    return 0;
   }
  }
 }

 if(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
  FLAC__bitwriter_release_buffer(encoder->private_->frame);
  FLAC__bitwriter_clear(encoder->private_->frame);
  encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
  return 0;
 }

 FLAC__bitwriter_release_buffer(encoder->private_->frame);
 FLAC__bitwriter_clear(encoder->private_->frame);

 if(samples > 0) {
  encoder->private_->streaminfo.data.stream_info.min_framesize = ((bytes) <= (encoder->private_->streaminfo.data.stream_info.min_framesize) ? (bytes) : (encoder->private_->streaminfo.data.stream_info.min_framesize));
  encoder->private_->streaminfo.data.stream_info.max_framesize = ((bytes) >= (encoder->private_->streaminfo.data.stream_info.max_framesize) ? (bytes) : (encoder->private_->streaminfo.data.stream_info.max_framesize));
 }

 return 1;
}

FLAC__StreamEncoderWriteStatus write_frame_(FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, uint32_t samples, FLAC__bool is_last_block)
{
 FLAC__StreamEncoderWriteStatus status;
 FLAC__uint64 output_position = 0;


 (void)is_last_block;



 if(encoder->private_->tell_callback && encoder->private_->tell_callback(encoder, &output_position, encoder->private_->client_data) == FLAC__STREAM_ENCODER_TELL_STATUS_ERROR) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
  return FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;
 }




 if(samples == 0) {
  FLAC__MetadataType type = (buffer[0] & 0x7f);
  if(type == FLAC__METADATA_TYPE_STREAMINFO)
   encoder->protected_->streaminfo_offset = output_position;
  else if(type == FLAC__METADATA_TYPE_SEEKTABLE && encoder->protected_->seektable_offset == 0)
   encoder->protected_->seektable_offset = output_position;
 }






 if(0 != encoder->private_->seek_table && encoder->protected_->audio_offset > 0 && encoder->private_->seek_table->num_points > 0) {
  const uint32_t blocksize = FLAC__stream_encoder_get_blocksize(encoder);
  const FLAC__uint64 frame_first_sample = encoder->private_->samples_written;
  const FLAC__uint64 frame_last_sample = frame_first_sample + (FLAC__uint64)blocksize - 1;
  FLAC__uint64 test_sample;
  uint32_t i;
  for(i = encoder->private_->first_seekpoint_to_check; i < encoder->private_->seek_table->num_points; i++) {
   test_sample = encoder->private_->seek_table->points[i].sample_number;
   if(test_sample > frame_last_sample) {
    break;
   }
   else if(test_sample >= frame_first_sample) {
    encoder->private_->seek_table->points[i].sample_number = frame_first_sample;
    encoder->private_->seek_table->points[i].stream_offset = output_position - encoder->protected_->audio_offset;
    encoder->private_->seek_table->points[i].frame_samples = blocksize;
    encoder->private_->first_seekpoint_to_check++;






   }
   else {
    encoder->private_->first_seekpoint_to_check++;
   }
  }
 }
# 2823 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 status = encoder->private_->write_callback(encoder, buffer, bytes, samples, encoder->private_->current_frame_number, encoder->private_->client_data);

 if(status == FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
  encoder->private_->bytes_written += bytes;
  encoder->private_->samples_written += samples;




  encoder->private_->frames_written = ((encoder->private_->frames_written) >= (encoder->private_->current_frame_number+1) ? (encoder->private_->frames_written) : (encoder->private_->current_frame_number+1));
 }
 else
  encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;

 return status;
}


void update_metadata_(const FLAC__StreamEncoder *encoder)
{
 FLAC__byte b[((6u) >= ((18u)) ? (6u) : ((18u)))];
 const FLAC__StreamMetadata *metadata = &encoder->private_->streaminfo;
 FLAC__uint64 samples = metadata->data.stream_info.total_samples;
 const uint32_t min_framesize = metadata->data.stream_info.min_framesize;
 const uint32_t max_framesize = metadata->data.stream_info.max_framesize;
 const uint32_t bps = metadata->data.stream_info.bits_per_sample;
 FLAC__StreamEncoderSeekStatus seek_status;

                                                               ;
# 2861 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 {
  const uint32_t md5_offset =
   (4u) +
   (
    FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN
   ) / 8;

  if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + md5_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
   if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
    encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
   return;
  }
  if(encoder->private_->write_callback(encoder, metadata->data.stream_info.md5sum, 16, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
   return;
  }
 }




 {
  const uint32_t total_samples_byte_offset =
   (4u) +
   (
    FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN
    - 4
   ) / 8;
  if(samples > (1ULL << FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN))
   samples = 0;

  b[0] = ((FLAC__byte)(bps-1) << 4) | (FLAC__byte)((samples >> 32) & 0x0F);
  b[1] = (FLAC__byte)((samples >> 24) & 0xFF);
  b[2] = (FLAC__byte)((samples >> 16) & 0xFF);
  b[3] = (FLAC__byte)((samples >> 8) & 0xFF);
  b[4] = (FLAC__byte)(samples & 0xFF);
  if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + total_samples_byte_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
   if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
    encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
   return;
  }
  if(encoder->private_->write_callback(encoder, b, 5, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
   return;
  }
 }




 {
  const uint32_t min_framesize_offset =
   (4u) +
   (
    FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
    FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN
   ) / 8;

  b[0] = (FLAC__byte)((min_framesize >> 16) & 0xFF);
  b[1] = (FLAC__byte)((min_framesize >> 8) & 0xFF);
  b[2] = (FLAC__byte)(min_framesize & 0xFF);
  b[3] = (FLAC__byte)((max_framesize >> 16) & 0xFF);
  b[4] = (FLAC__byte)((max_framesize >> 8) & 0xFF);
  b[5] = (FLAC__byte)(max_framesize & 0xFF);
  if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + min_framesize_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
   if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
    encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
   return;
  }
  if(encoder->private_->write_callback(encoder, b, 6, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
   return;
  }
 }




 if(0 != encoder->private_->seek_table && encoder->private_->seek_table->num_points > 0 && encoder->protected_->seektable_offset > 0) {
  uint32_t i;

  FLAC__format_seektable_sort(encoder->private_->seek_table);

                                                                              ;

  if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->seektable_offset + (4u), encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
   if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
    encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
   return;
  }

  for(i = 0; i < encoder->private_->seek_table->num_points; i++) {
   FLAC__uint64 xx;
   uint32_t x;
   xx = encoder->private_->seek_table->points[i].sample_number;
   b[7] = (FLAC__byte)xx; xx >>= 8;
   b[6] = (FLAC__byte)xx; xx >>= 8;
   b[5] = (FLAC__byte)xx; xx >>= 8;
   b[4] = (FLAC__byte)xx; xx >>= 8;
   b[3] = (FLAC__byte)xx; xx >>= 8;
   b[2] = (FLAC__byte)xx; xx >>= 8;
   b[1] = (FLAC__byte)xx; xx >>= 8;
   b[0] = (FLAC__byte)xx; xx >>= 8;
   xx = encoder->private_->seek_table->points[i].stream_offset;
   b[15] = (FLAC__byte)xx; xx >>= 8;
   b[14] = (FLAC__byte)xx; xx >>= 8;
   b[13] = (FLAC__byte)xx; xx >>= 8;
   b[12] = (FLAC__byte)xx; xx >>= 8;
   b[11] = (FLAC__byte)xx; xx >>= 8;
   b[10] = (FLAC__byte)xx; xx >>= 8;
   b[9] = (FLAC__byte)xx; xx >>= 8;
   b[8] = (FLAC__byte)xx; xx >>= 8;
   x = encoder->private_->seek_table->points[i].frame_samples;
   b[17] = (FLAC__byte)x; x >>= 8;
   b[16] = (FLAC__byte)x; x >>= 8;
   if(encoder->private_->write_callback(encoder, b, 18, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
    encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
    return;
   }
  }
 }
}
# 3188 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
FLAC__bool process_frame_(FLAC__StreamEncoder *encoder, FLAC__bool is_last_block)
{
 FLAC__uint16 crc;
                                                                    ;




 if(encoder->protected_->do_md5 && !FLAC__MD5Accumulate(&encoder->private_->md5context, (const FLAC__int32 * const *)encoder->private_->integer_signal, encoder->protected_->channels, encoder->protected_->blocksize, (encoder->protected_->bits_per_sample+7) / 8)) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
  return 0;
 }




 if(!process_subframes_(encoder)) {

  return 0;
 }




 if(!FLAC__bitwriter_zero_pad_to_byte_boundary(encoder->private_->frame)) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
  return 0;
 }




                                                                        ;
 if(
  !FLAC__bitwriter_get_write_crc16(encoder->private_->frame, &crc) ||
  !FLAC__bitwriter_write_raw_uint32(encoder->private_->frame, crc, FLAC__FRAME_FOOTER_CRC_LEN)
 ) {
  encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
  return 0;
 }




 if(!write_bitbuffer_(encoder, encoder->protected_->blocksize, is_last_block)) {

  return 0;
 }




 encoder->private_->current_sample_number = 0;
 encoder->private_->current_frame_number++;
 encoder->private_->streaminfo.data.stream_info.total_samples += (FLAC__uint64)encoder->protected_->blocksize;

 return 1;
}

FLAC__bool process_subframes_(FLAC__StreamEncoder *encoder)
{
 FLAC__FrameHeader frame_header;
 uint32_t channel, min_partition_order = encoder->protected_->min_residual_partition_order, max_partition_order;
 FLAC__bool do_independent, do_mid_side, backup_disable_constant_subframes = encoder->private_->disable_constant_subframes, all_subframes_constant = 1;





 max_partition_order = FLAC__format_get_max_rice_partition_order_from_blocksize(encoder->protected_->blocksize);
 max_partition_order = ((max_partition_order) <= (encoder->protected_->max_residual_partition_order) ? (max_partition_order) : (encoder->protected_->max_residual_partition_order));
 min_partition_order = ((min_partition_order) <= (max_partition_order) ? (min_partition_order) : (max_partition_order));




 frame_header.blocksize = encoder->protected_->blocksize;
 frame_header.sample_rate = encoder->protected_->sample_rate;
 frame_header.channels = encoder->protected_->channels;
 frame_header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT;
 frame_header.bits_per_sample = encoder->protected_->bits_per_sample;
 frame_header.number_type = FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER;
 frame_header.number.frame_number = encoder->private_->current_frame_number;




 if(encoder->protected_->do_mid_side_stereo) {
  if(encoder->protected_->loose_mid_side_stereo) {
   if(encoder->private_->loose_mid_side_stereo_frame_count == 0) {
    do_independent = 1;
    do_mid_side = 1;
   }
   else {
    do_independent = (encoder->private_->last_channel_assignment == FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT);
    do_mid_side = !do_independent;
   }
  }
  else {
   do_independent = 1;
   do_mid_side = 1;
  }
 }
 else {
  do_independent = 1;
  do_mid_side = 0;
 }

                                            ;




 if(do_independent) {
  for(channel = 0; channel < encoder->protected_->channels; channel++) {
   uint32_t w = get_wasted_bits_(encoder->private_->integer_signal[channel], encoder->protected_->blocksize);
   if (w > encoder->protected_->bits_per_sample) {
    w = encoder->protected_->bits_per_sample;
   }
   encoder->private_->subframe_workspace[channel][0].wasted_bits = encoder->private_->subframe_workspace[channel][1].wasted_bits = w;
   encoder->private_->subframe_bps[channel] = encoder->protected_->bits_per_sample - w;
  }
 }
 if(do_mid_side) {
                                                  ;
  for(channel = 0; channel < 2; channel++) {
   uint32_t w;
   if(encoder->protected_->bits_per_sample < 32 || channel == 0)
    w = get_wasted_bits_(encoder->private_->integer_signal_mid_side[channel], encoder->protected_->blocksize);
   else
    w = get_wasted_bits_wide_(encoder->private_->integer_signal_33bit_side, encoder->private_->integer_signal_mid_side[channel], encoder->protected_->blocksize);

   if (w > encoder->protected_->bits_per_sample) {
    w = encoder->protected_->bits_per_sample;
   }
   encoder->private_->subframe_workspace_mid_side[channel][0].wasted_bits = encoder->private_->subframe_workspace_mid_side[channel][1].wasted_bits = w;
   encoder->private_->subframe_bps_mid_side[channel] = encoder->protected_->bits_per_sample - w + (channel==0? 0:1);
  }
 }




 if(do_independent) {
  for(channel = 0; channel < encoder->protected_->channels; channel++) {
   if(encoder->protected_->limit_min_bitrate && all_subframes_constant && (channel + 1) == encoder->protected_->channels){



    encoder->private_->disable_constant_subframes = 1;
   }
   if(!
    process_subframe_(
     encoder,
     min_partition_order,
     max_partition_order,
     &frame_header,
     encoder->private_->subframe_bps[channel],
     encoder->private_->integer_signal[channel],
     encoder->private_->subframe_workspace_ptr[channel],
     encoder->private_->partitioned_rice_contents_workspace_ptr[channel],
     encoder->private_->residual_workspace[channel],
     encoder->private_->best_subframe+channel,
     encoder->private_->best_subframe_bits+channel
    )
   )
    return 0;
   if(encoder->private_->subframe_workspace[channel][encoder->private_->best_subframe[channel]].type != FLAC__SUBFRAME_TYPE_CONSTANT)
    all_subframes_constant = 0;
  }
 }




 if(do_mid_side) {
                                                  ;

  for(channel = 0; channel < 2; channel++) {
   void *integer_signal_;
   if(encoder->private_->subframe_bps_mid_side[channel] <= 32)
    integer_signal_ = encoder->private_->integer_signal_mid_side[channel];
   else
    integer_signal_ = encoder->private_->integer_signal_33bit_side;
   if(!
    process_subframe_(
     encoder,
     min_partition_order,
     max_partition_order,
     &frame_header,
     encoder->private_->subframe_bps_mid_side[channel],
     integer_signal_,
     encoder->private_->subframe_workspace_ptr_mid_side[channel],
     encoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[channel],
     encoder->private_->residual_workspace_mid_side[channel],
     encoder->private_->best_subframe_mid_side+channel,
     encoder->private_->best_subframe_bits_mid_side+channel
    )
   )
    return 0;
  }
 }




 if(do_mid_side) {
  uint32_t left_bps = 0, right_bps = 0;
  FLAC__Subframe *left_subframe = 0, *right_subframe = 0;
  FLAC__ChannelAssignment channel_assignment;

                                                  ;

  if(encoder->protected_->loose_mid_side_stereo && encoder->private_->loose_mid_side_stereo_frame_count > 0) {
   channel_assignment = (encoder->private_->last_channel_assignment == FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT? FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT : FLAC__CHANNEL_ASSIGNMENT_MID_SIDE);
  }
  else {
   uint32_t bits[4];
   uint32_t min_bits;
   int ca;

                                                          ;
                                                          ;
                                                          ;
                                                          ;
                                              ;


   bits[FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT] = encoder->private_->best_subframe_bits [0] + encoder->private_->best_subframe_bits [1];
   bits[FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE ] = encoder->private_->best_subframe_bits [0] + encoder->private_->best_subframe_bits_mid_side[1];
   bits[FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE ] = encoder->private_->best_subframe_bits [1] + encoder->private_->best_subframe_bits_mid_side[1];
   bits[FLAC__CHANNEL_ASSIGNMENT_MID_SIDE ] = encoder->private_->best_subframe_bits_mid_side[0] + encoder->private_->best_subframe_bits_mid_side[1];

   channel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT;
   min_bits = bits[channel_assignment];



   ca = encoder->protected_->loose_mid_side_stereo ? 3 : 1;
   for( ; ca <= 3; ca++) {
    if(bits[ca] < min_bits) {
     min_bits = bits[ca];
     channel_assignment = (FLAC__ChannelAssignment)ca;
    }
   }
  }

  frame_header.channel_assignment = channel_assignment;

  if(!FLAC__frame_add_header(&frame_header, encoder->private_->frame)) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
   return 0;
  }

  switch(channel_assignment) {
   case FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:
    left_subframe = &encoder->private_->subframe_workspace [0][encoder->private_->best_subframe [0]];
    right_subframe = &encoder->private_->subframe_workspace [1][encoder->private_->best_subframe [1]];
    break;
   case FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:
    left_subframe = &encoder->private_->subframe_workspace [0][encoder->private_->best_subframe [0]];
    right_subframe = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];
    break;
   case FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:
    left_subframe = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];
    right_subframe = &encoder->private_->subframe_workspace [1][encoder->private_->best_subframe [1]];
    break;
   case FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:
    left_subframe = &encoder->private_->subframe_workspace_mid_side[0][encoder->private_->best_subframe_mid_side[0]];
    right_subframe = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];
    break;
   default:
                   ;
  }

  switch(channel_assignment) {
   case FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:
    left_bps = encoder->private_->subframe_bps [0];
    right_bps = encoder->private_->subframe_bps [1];
    break;
   case FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:
    left_bps = encoder->private_->subframe_bps [0];
    right_bps = encoder->private_->subframe_bps_mid_side[1];
    break;
   case FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:
    left_bps = encoder->private_->subframe_bps_mid_side[1];
    right_bps = encoder->private_->subframe_bps [1];
    break;
   case FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:
    left_bps = encoder->private_->subframe_bps_mid_side[0];
    right_bps = encoder->private_->subframe_bps_mid_side[1];
    break;
   default:
                   ;
  }


  if(!add_subframe_(encoder, frame_header.blocksize, left_bps , left_subframe , encoder->private_->frame))
   return 0;
  if(!add_subframe_(encoder, frame_header.blocksize, right_bps, right_subframe, encoder->private_->frame))
   return 0;
 }
 else {
  if(!FLAC__frame_add_header(&frame_header, encoder->private_->frame)) {
   encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
   return 0;
  }

  for(channel = 0; channel < encoder->protected_->channels; channel++) {
   if(!add_subframe_(encoder, frame_header.blocksize, encoder->private_->subframe_bps[channel], &encoder->private_->subframe_workspace[channel][encoder->private_->best_subframe[channel]], encoder->private_->frame)) {

    return 0;
   }
  }
 }

 if(encoder->protected_->loose_mid_side_stereo) {
  encoder->private_->loose_mid_side_stereo_frame_count++;
  if(encoder->private_->loose_mid_side_stereo_frame_count >= encoder->private_->loose_mid_side_stereo_frames)
   encoder->private_->loose_mid_side_stereo_frame_count = 0;
 }

 encoder->private_->last_channel_assignment = frame_header.channel_assignment;
 encoder->private_->disable_constant_subframes = backup_disable_constant_subframes;

 return 1;
}

static inline void set_next_subdivide_tukey(FLAC__int32 parts, uint32_t * apodizations, uint32_t * current_depth, uint32_t * current_part){

 if(*current_depth == 2){

  if(*current_part == 0){
   *current_part = 2;
  }else{
   *current_part = 0;
   (*current_depth)++;
  }
 }else if((*current_part) < (2*(*current_depth)-1)){
  (*current_part)++;
 }else{
  *current_part = 0;
  (*current_depth)++;
 }


 if(*current_depth > (uint32_t) parts){
  (*apodizations)++;
  *current_depth = 1;
  *current_part = 0;
 }
}

FLAC__bool process_subframe_(
 FLAC__StreamEncoder *encoder,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 const FLAC__FrameHeader *frame_header,
 uint32_t subframe_bps,
 const void *integer_signal,
 FLAC__Subframe *subframe[2],
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents[2],
 FLAC__int32 *residual[2],
 uint32_t *best_subframe,
 uint32_t *best_bits
)
{

 float fixed_residual_bits_per_sample[(4u)+1];




 double lpc_residual_bits_per_sample;
 double autoc[(32u)+1];
 double autoc_root[(32u)+1];
 double lpc_error[(32u)];
 uint32_t min_lpc_order, max_lpc_order, lpc_order;
 uint32_t min_qlp_coeff_precision, max_qlp_coeff_precision, qlp_coeff_precision;

 uint32_t min_fixed_order, max_fixed_order, guess_fixed_order, fixed_order;
 uint32_t _candidate_bits, _best_bits;
 uint32_t _best_subframe;

 const uint32_t rice_parameter_limit = FLAC__stream_encoder_get_bits_per_sample(encoder) > 16? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;

                                          ;


 _best_subframe = 0;
 if(encoder->private_->disable_verbatim_subframes && frame_header->blocksize >= (4u))
  _best_bits = 4294967295U;
 else
  _best_bits = evaluate_verbatim_subframe_(encoder, integer_signal, frame_header->blocksize, subframe_bps, subframe[_best_subframe]);
 *best_bits = _best_bits;

 if(frame_header->blocksize > (4u)) {
  uint32_t signal_is_constant = 0;
# 3594 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
  if(subframe_bps < 28){
   if(subframe_bps + FLAC__bitmath_ilog2((frame_header->blocksize-(4u))*17) < 32)
    guess_fixed_order = encoder->private_->local_fixed_compute_best_predictor(((FLAC__int32 *)integer_signal)+(4u), frame_header->blocksize-(4u), fixed_residual_bits_per_sample);
   else
    guess_fixed_order = encoder->private_->local_fixed_compute_best_predictor_wide(((FLAC__int32 *)integer_signal)+(4u), frame_header->blocksize-(4u), fixed_residual_bits_per_sample);
  }
  else
   if(subframe_bps <= 32)
    guess_fixed_order = FLAC__fixed_compute_best_predictor_limit_residual(((FLAC__int32 *)integer_signal),frame_header->blocksize, fixed_residual_bits_per_sample);
   else
    guess_fixed_order = FLAC__fixed_compute_best_predictor_limit_residual_33bit(((FLAC__int64 *)integer_signal),frame_header->blocksize, fixed_residual_bits_per_sample);


  if(
   !encoder->private_->disable_constant_subframes &&

   fixed_residual_bits_per_sample[1] == 0.0



  ) {

   uint32_t i;
   signal_is_constant = 1;
   if(subframe_bps <= 32){
    const FLAC__int32 *integer_signal_ = integer_signal;
    for(i = 1; i < frame_header->blocksize; i++) {
     if(integer_signal_[0] != integer_signal_[i]) {
      signal_is_constant = 0;
      break;
     }
    }
   }
   else {
    const FLAC__int64 *integer_signal_ = integer_signal;
    for(i = 1; i < frame_header->blocksize; i++) {
     if(integer_signal_[0] != integer_signal_[i]) {
      signal_is_constant = 0;
      break;
     }
    }
   }
  }
  if(signal_is_constant) {
   if(subframe_bps <= 32)
    _candidate_bits = evaluate_constant_subframe_(encoder, ((FLAC__int32 *)integer_signal)[0], frame_header->blocksize, subframe_bps, subframe[!_best_subframe]);
   else
    _candidate_bits = evaluate_constant_subframe_(encoder, ((FLAC__int64 *)integer_signal)[0], frame_header->blocksize, subframe_bps, subframe[!_best_subframe]);

   if(_candidate_bits < _best_bits) {
    _best_subframe = !_best_subframe;
    _best_bits = _candidate_bits;
   }
  }
  else {
   if(!encoder->private_->disable_fixed_subframes || (encoder->protected_->max_lpc_order == 0 && _best_bits == (2147483647 *2U +1U))) {

    if(encoder->protected_->do_exhaustive_model_search) {
     min_fixed_order = 0;
     max_fixed_order = (4u);
    }
    else {
     min_fixed_order = max_fixed_order = guess_fixed_order;
    }
    if(max_fixed_order >= frame_header->blocksize)
     max_fixed_order = frame_header->blocksize - 1;
    for(fixed_order = min_fixed_order; fixed_order <= max_fixed_order; fixed_order++) {

     if(fixed_residual_bits_per_sample[fixed_order] >= (float)subframe_bps)
      continue;




     _candidate_bits =
      evaluate_fixed_subframe_(
       encoder,
       integer_signal,
       residual[!_best_subframe],
       encoder->private_->abs_residual_partition_sums,
       encoder->private_->raw_bits_per_partition,
       frame_header->blocksize,
       subframe_bps,
       fixed_order,
       rice_parameter_limit,
       min_partition_order,
       max_partition_order,
       encoder->protected_->do_escape_coding,
       encoder->protected_->rice_parameter_search_dist,
       subframe[!_best_subframe],
       partitioned_rice_contents[!_best_subframe]
      );
     if(_candidate_bits < _best_bits) {
      _best_subframe = !_best_subframe;
      _best_bits = _candidate_bits;
     }
    }
   }



   if(encoder->protected_->max_lpc_order > 0) {
    if(encoder->protected_->max_lpc_order >= frame_header->blocksize)
     max_lpc_order = frame_header->blocksize-1;
    else
     max_lpc_order = encoder->protected_->max_lpc_order;
    if(max_lpc_order > 0) {
     uint32_t a, b = 1, c = 0;
     for (a = 0; a < encoder->protected_->num_apodizations;) {
      uint32_t max_lpc_order_this_apodization = max_lpc_order;
      if(b == 1){

       if(subframe_bps <= 32)
        FLAC__lpc_window_data(integer_signal, encoder->private_->window[a], encoder->private_->windowed_signal, frame_header->blocksize);
       else
        FLAC__lpc_window_data_wide(integer_signal, encoder->private_->window[a], encoder->private_->windowed_signal, frame_header->blocksize);
       encoder->private_->local_lpc_compute_autocorrelation(encoder->private_->windowed_signal, frame_header->blocksize, max_lpc_order_this_apodization+1, autoc);
       if(encoder->protected_->apodizations[a].type == FLAC__APODIZATION_SUBDIVIDE_TUKEY){
        uint32_t i;
        for(i = 0; i < max_lpc_order_this_apodization; i++)
         autoc_root[i] = autoc[i];
        b++;
       }else{
        a++;
       }
      }
      else {

       if(frame_header->blocksize/b <= (32u)) {





        set_next_subdivide_tukey(encoder->protected_->apodizations[a].parameters.subdivide_tukey.parts, &a, &b, &c);
        continue;
       }
       if(!(c % 2)){

        if(subframe_bps <= 32)
         FLAC__lpc_window_data_partial(integer_signal, encoder->private_->window[a], encoder->private_->windowed_signal, frame_header->blocksize, frame_header->blocksize/b/2, (c/2*frame_header->blocksize)/b);
        else
         FLAC__lpc_window_data_partial_wide(integer_signal, encoder->private_->window[a], encoder->private_->windowed_signal, frame_header->blocksize, frame_header->blocksize/b/2, (c/2*frame_header->blocksize)/b);
        encoder->private_->local_lpc_compute_autocorrelation(encoder->private_->windowed_signal, frame_header->blocksize/b, max_lpc_order_this_apodization+1, autoc);
       }else{


        uint32_t i;
        for(i = 0; i < max_lpc_order_this_apodization; i++)
         autoc[i] = autoc_root[i] - autoc[i];
       }

       set_next_subdivide_tukey(encoder->protected_->apodizations[a].parameters.subdivide_tukey.parts, &a, &b, &c);
      }


      if(autoc[0] != 0.0) {
       FLAC__lpc_compute_lp_coefficients(autoc, &max_lpc_order_this_apodization, encoder->private_->lp_coeff, lpc_error);
       if(encoder->protected_->do_exhaustive_model_search) {
        min_lpc_order = 1;
       }
       else {
        const uint32_t guess_lpc_order =
         FLAC__lpc_compute_best_order(
          lpc_error,
          max_lpc_order_this_apodization,
          frame_header->blocksize,
          subframe_bps + (
           encoder->protected_->do_qlp_coeff_prec_search?
            (5u) :
            encoder->protected_->qlp_coeff_precision
          )
         );
        min_lpc_order = max_lpc_order_this_apodization = guess_lpc_order;
       }
       if(max_lpc_order_this_apodization >= frame_header->blocksize)
        max_lpc_order_this_apodization = frame_header->blocksize - 1;
       for(lpc_order = min_lpc_order; lpc_order <= max_lpc_order_this_apodization; lpc_order++) {
        lpc_residual_bits_per_sample = FLAC__lpc_compute_expected_bits_per_residual_sample(lpc_error[lpc_order-1], frame_header->blocksize-lpc_order);
        if(lpc_residual_bits_per_sample >= (double)subframe_bps)
         continue;
        if(encoder->protected_->do_qlp_coeff_prec_search) {
         min_qlp_coeff_precision = (5u);

         if(subframe_bps <= 17) {
          max_qlp_coeff_precision = ((32 - subframe_bps - FLAC__bitmath_ilog2(lpc_order)) <= ((15u)) ? (32 - subframe_bps - FLAC__bitmath_ilog2(lpc_order)) : ((15u)));
          max_qlp_coeff_precision = ((max_qlp_coeff_precision) >= (min_qlp_coeff_precision) ? (max_qlp_coeff_precision) : (min_qlp_coeff_precision));
         }
         else
          max_qlp_coeff_precision = (15u);
        }
        else {
         min_qlp_coeff_precision = max_qlp_coeff_precision = encoder->protected_->qlp_coeff_precision;
        }
        for(qlp_coeff_precision = min_qlp_coeff_precision; qlp_coeff_precision <= max_qlp_coeff_precision; qlp_coeff_precision++) {
         _candidate_bits =
          evaluate_lpc_subframe_(
           encoder,
           integer_signal,
           residual[!_best_subframe],
           encoder->private_->abs_residual_partition_sums,
           encoder->private_->raw_bits_per_partition,
           encoder->private_->lp_coeff[lpc_order-1],
           frame_header->blocksize,
           subframe_bps,
           lpc_order,
           qlp_coeff_precision,
           rice_parameter_limit,
           min_partition_order,
           max_partition_order,
           encoder->protected_->do_escape_coding,
           encoder->protected_->rice_parameter_search_dist,
           subframe[!_best_subframe],
           partitioned_rice_contents[!_best_subframe]
          );
         if(_candidate_bits > 0) {
          if(_candidate_bits < _best_bits) {
           _best_subframe = !_best_subframe;
           _best_bits = _candidate_bits;
          }
         }
        }
       }
      }
     }
    }
   }

  }
 }


 if(_best_bits == 4294967295U) {
                                   ;
  _best_bits = evaluate_verbatim_subframe_(encoder, integer_signal, frame_header->blocksize, subframe_bps, subframe[_best_subframe]);
 }

 *best_subframe = _best_subframe;
 *best_bits = _best_bits;

 return 1;
}

FLAC__bool add_subframe_(
 FLAC__StreamEncoder *encoder,
 uint32_t blocksize,
 uint32_t subframe_bps,
 const FLAC__Subframe *subframe,
 FLAC__BitWriter *frame
)
{
 switch(subframe->type) {
  case FLAC__SUBFRAME_TYPE_CONSTANT:
   if(!FLAC__subframe_add_constant(&(subframe->data.constant), subframe_bps, subframe->wasted_bits, frame)) {
    encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
    return 0;
   }
   break;
  case FLAC__SUBFRAME_TYPE_FIXED:
   if(!FLAC__subframe_add_fixed(&(subframe->data.fixed), blocksize - subframe->data.fixed.order, subframe_bps, subframe->wasted_bits, frame)) {
    encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
    return 0;
   }
   break;
  case FLAC__SUBFRAME_TYPE_LPC:
   if(!FLAC__subframe_add_lpc(&(subframe->data.lpc), blocksize - subframe->data.lpc.order, subframe_bps, subframe->wasted_bits, frame)) {
    encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
    return 0;
   }
   break;
  case FLAC__SUBFRAME_TYPE_VERBATIM:
   if(!FLAC__subframe_add_verbatim(&(subframe->data.verbatim), blocksize, subframe_bps, subframe->wasted_bits, frame)) {
    encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
    return 0;
   }
   break;
  default:
                  ;
 }

 return 1;
}
# 3908 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
uint32_t evaluate_constant_subframe_(
 FLAC__StreamEncoder *encoder,
 const FLAC__int64 signal,
 uint32_t blocksize,
 uint32_t subframe_bps,
 FLAC__Subframe *subframe
)
{
 uint32_t estimate;
 subframe->type = FLAC__SUBFRAME_TYPE_CONSTANT;
 subframe->data.constant.value = signal;

 estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + subframe_bps;




 (void)encoder, (void)blocksize;


 return estimate;
}

uint32_t evaluate_fixed_subframe_(
 FLAC__StreamEncoder *encoder,
 const void *signal,
 FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t raw_bits_per_partition[],
 uint32_t blocksize,
 uint32_t subframe_bps,
 uint32_t order,
 uint32_t rice_parameter_limit,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 FLAC__bool do_escape_coding,
 uint32_t rice_parameter_search_dist,
 FLAC__Subframe *subframe,
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
)
{
 uint32_t i, residual_bits, estimate;
 const uint32_t residual_samples = blocksize - order;

 if((subframe_bps + order) <= 32)
  FLAC__fixed_compute_residual(((FLAC__int32 *)signal)+order, residual_samples, order, residual);
 else if(subframe_bps <= 32)
  FLAC__fixed_compute_residual_wide(((FLAC__int32 *)signal)+order, residual_samples, order, residual);
 else
  FLAC__fixed_compute_residual_wide_33bit(((FLAC__int64 *)signal)+order, residual_samples, order, residual);

 subframe->type = FLAC__SUBFRAME_TYPE_FIXED;

 subframe->data.fixed.entropy_coding_method.type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE;
 subframe->data.fixed.entropy_coding_method.data.partitioned_rice.contents = partitioned_rice_contents;
 subframe->data.fixed.residual = residual;

 residual_bits =
  find_best_partition_order_(
   encoder->private_,
   residual,
   abs_residual_partition_sums,
   raw_bits_per_partition,
   residual_samples,
   order,
   rice_parameter_limit,
   min_partition_order,
   max_partition_order,
   subframe_bps,
   do_escape_coding,
   rice_parameter_search_dist,
   &subframe->data.fixed.entropy_coding_method
  );

 subframe->data.fixed.order = order;
 if(subframe_bps <= 32)
  for(i = 0; i < order; i++)
   subframe->data.fixed.warmup[i] = ((FLAC__int32 *)signal)[i];
 else
  for(i = 0; i < order; i++)
   subframe->data.fixed.warmup[i] = ((FLAC__int64 *)signal)[i];

 estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + (order * subframe_bps);
 if(residual_bits < 4294967295U - estimate)
  estimate += residual_bits;
 else
  estimate = 4294967295U;





 return estimate;
}


uint32_t evaluate_lpc_subframe_(
 FLAC__StreamEncoder *encoder,
 const void *signal,
 FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t raw_bits_per_partition[],
 const FLAC__real lp_coeff[],
 uint32_t blocksize,
 uint32_t subframe_bps,
 uint32_t order,
 uint32_t qlp_coeff_precision,
 uint32_t rice_parameter_limit,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 FLAC__bool do_escape_coding,
 uint32_t rice_parameter_search_dist,
 FLAC__Subframe *subframe,
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
)
{
 FLAC__int32 qlp_coeff[(32u)];
 uint32_t i, residual_bits, estimate;
 int quantization, ret;
 const uint32_t residual_samples = blocksize - order;


 if(subframe_bps <= 17) {
                         ;
                                            ;
  qlp_coeff_precision = ((qlp_coeff_precision) <= (32 - subframe_bps - FLAC__bitmath_ilog2(order)) ? (qlp_coeff_precision) : (32 - subframe_bps - FLAC__bitmath_ilog2(order)));
 }

 ret = FLAC__lpc_quantize_coefficients(lp_coeff, order, qlp_coeff_precision, qlp_coeff, &quantization);
 if(ret != 0)
  return 0;

 if(FLAC__lpc_max_residual_bps(subframe_bps, qlp_coeff, order, quantization) > 32) {
  if(subframe_bps <= 32){
   if(!FLAC__lpc_compute_residual_from_qlp_coefficients_limit_residual(((FLAC__int32 *)signal)+order, residual_samples, qlp_coeff, order, quantization, residual))
    return 0;
  }
  else
   if(!FLAC__lpc_compute_residual_from_qlp_coefficients_limit_residual_33bit(((FLAC__int64 *)signal)+order, residual_samples, qlp_coeff, order, quantization, residual))
    return 0;
 }
 else
  if(FLAC__lpc_max_prediction_before_shift_bps(subframe_bps, qlp_coeff, order) <= 32)
   if(subframe_bps <= 16 && qlp_coeff_precision <= 16)
    encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit(((FLAC__int32 *)signal)+order, residual_samples, qlp_coeff, order, quantization, residual);
   else
    encoder->private_->local_lpc_compute_residual_from_qlp_coefficients(((FLAC__int32 *)signal)+order, residual_samples, qlp_coeff, order, quantization, residual);
  else
   encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit(((FLAC__int32 *)signal)+order, residual_samples, qlp_coeff, order, quantization, residual);

 subframe->type = FLAC__SUBFRAME_TYPE_LPC;

 subframe->data.lpc.entropy_coding_method.type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE;
 subframe->data.lpc.entropy_coding_method.data.partitioned_rice.contents = partitioned_rice_contents;
 subframe->data.lpc.residual = residual;

 residual_bits =
  find_best_partition_order_(
   encoder->private_,
   residual,
   abs_residual_partition_sums,
   raw_bits_per_partition,
   residual_samples,
   order,
   rice_parameter_limit,
   min_partition_order,
   max_partition_order,
   subframe_bps,
   do_escape_coding,
   rice_parameter_search_dist,
   &subframe->data.lpc.entropy_coding_method
  );

 subframe->data.lpc.order = order;
 subframe->data.lpc.qlp_coeff_precision = qlp_coeff_precision;
 subframe->data.lpc.quantization_level = quantization;
 memcpy(subframe->data.lpc.qlp_coeff, qlp_coeff, sizeof(FLAC__int32)*(32u));
 if(subframe_bps <= 32)
  for(i = 0; i < order; i++)
   subframe->data.lpc.warmup[i] = ((FLAC__int32 *)signal)[i];
 else
  for(i = 0; i < order; i++)
   subframe->data.lpc.warmup[i] = ((FLAC__int64 *)signal)[i];


 estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN + FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN + (order * (qlp_coeff_precision + subframe_bps));
 if(residual_bits < 4294967295U - estimate)
  estimate += residual_bits;
 else
  estimate = 4294967295U;





 return estimate;
}


uint32_t evaluate_verbatim_subframe_(
 FLAC__StreamEncoder *encoder,
 const void *signal,
 uint32_t blocksize,
 uint32_t subframe_bps,
 FLAC__Subframe *subframe
)
{
 uint32_t estimate;

 subframe->type = FLAC__SUBFRAME_TYPE_VERBATIM;

 if(subframe_bps <= 32){
  subframe->data.verbatim.data_type = FLAC__VERBATIM_SUBFRAME_DATA_TYPE_INT32;
  subframe->data.verbatim.data.int32 = signal;
 }
 else {
  subframe->data.verbatim.data_type = FLAC__VERBATIM_SUBFRAME_DATA_TYPE_INT64;
  subframe->data.verbatim.data.int64 = signal;
 }

 estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + (blocksize * subframe_bps);




 (void)encoder;


 return estimate;
}

uint32_t find_best_partition_order_(
 FLAC__StreamEncoderPrivate *private_,
 const FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t raw_bits_per_partition[],
 uint32_t residual_samples,
 uint32_t predictor_order,
 uint32_t rice_parameter_limit,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 uint32_t bps,
 FLAC__bool do_escape_coding,
 uint32_t rice_parameter_search_dist,
 FLAC__EntropyCodingMethod *best_ecm
)
{
 uint32_t residual_bits, best_residual_bits = 0;
 uint32_t best_parameters_index = 0;
 uint32_t best_partition_order = 0;
 const uint32_t blocksize = residual_samples + predictor_order;

 max_partition_order = FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(max_partition_order, blocksize, predictor_order);
 min_partition_order = ((min_partition_order) <= (max_partition_order) ? (min_partition_order) : (max_partition_order));

 private_->local_precompute_partition_info_sums(residual, abs_residual_partition_sums, residual_samples, predictor_order, min_partition_order, max_partition_order, bps);

 if(do_escape_coding)
  precompute_partition_info_escapes_(residual, raw_bits_per_partition, residual_samples, predictor_order, min_partition_order, max_partition_order);

 {
  int partition_order;
  uint32_t sum;

  for(partition_order = (int)max_partition_order, sum = 0; partition_order >= (int)min_partition_order; partition_order--) {
   if(!
    set_partitioned_rice_(



     abs_residual_partition_sums+sum,
     raw_bits_per_partition+sum,
     residual_samples,
     predictor_order,
     rice_parameter_limit,
     rice_parameter_search_dist,
     (uint32_t)partition_order,
     do_escape_coding,
     &private_->partitioned_rice_contents_extra[!best_parameters_index],
     &residual_bits
    )
   )
   {
                                         ;
    break;
   }
   sum += 1u << partition_order;
   if(best_residual_bits == 0 || residual_bits < best_residual_bits) {
    best_residual_bits = residual_bits;
    best_parameters_index = !best_parameters_index;
    best_partition_order = partition_order;
   }
  }
 }

 best_ecm->data.partitioned_rice.order = best_partition_order;

 {




  FLAC__EntropyCodingMethod_PartitionedRiceContents* prc = (FLAC__EntropyCodingMethod_PartitionedRiceContents*)best_ecm->data.partitioned_rice.contents;
  uint32_t partition;


  memcpy(prc->parameters, private_->partitioned_rice_contents_extra[best_parameters_index].parameters, (uint32_t)sizeof(uint32_t)*(1<<(best_partition_order)));
  if(do_escape_coding)
   memcpy(prc->raw_bits, private_->partitioned_rice_contents_extra[best_parameters_index].raw_bits, (uint32_t)sizeof(uint32_t)*(1<<(best_partition_order)));





  for(partition = 0; partition < (1u<<best_partition_order); partition++) {
   if(prc->parameters[partition] >= FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER) {
    best_ecm->type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2;
    break;
   }
  }
 }

 return best_residual_bits;
}

void precompute_partition_info_sums_(
 const FLAC__int32 residual[],
 FLAC__uint64 abs_residual_partition_sums[],
 uint32_t residual_samples,
 uint32_t predictor_order,
 uint32_t min_partition_order,
 uint32_t max_partition_order,
 uint32_t bps
)
{
 const uint32_t default_partition_samples = (residual_samples + predictor_order) >> max_partition_order;
 uint32_t partitions = 1u << max_partition_order;

                                                          ;


 {
  const uint32_t threshold = 32 - FLAC__bitmath_ilog2(default_partition_samples);
  uint32_t partition, residual_sample, end = (uint32_t)(-(int)predictor_order);

  if(bps + 4 < threshold) {
   for(partition = residual_sample = 0; partition < partitions; partition++) {
    FLAC__uint32 abs_residual_partition_sum = 0;
    end += default_partition_samples;
    for( ; residual_sample < end; residual_sample++)
     abs_residual_partition_sum += abs(residual[residual_sample]);
    abs_residual_partition_sums[partition] = abs_residual_partition_sum;
   }
  }
  else {
   for(partition = residual_sample = 0; partition < partitions; partition++) {
    FLAC__uint64 abs_residual_partition_sum64 = 0;
    end += default_partition_samples;
    for( ; residual_sample < end; residual_sample++)
     abs_residual_partition_sum64 += abs(residual[residual_sample]);
    abs_residual_partition_sums[partition] = abs_residual_partition_sum64;
   }
  }
 }


 {
  uint32_t from_partition = 0, to_partition = partitions;
  int partition_order;
  for(partition_order = (int)max_partition_order - 1; partition_order >= (int)min_partition_order; partition_order--) {
   uint32_t i;
   partitions >>= 1;
   for(i = 0; i < partitions; i++) {
    abs_residual_partition_sums[to_partition++] =
     abs_residual_partition_sums[from_partition ] +
     abs_residual_partition_sums[from_partition+1];
    from_partition += 2;
   }
  }
 }
}

void precompute_partition_info_escapes_(
 const FLAC__int32 residual[],
 uint32_t raw_bits_per_partition[],
 uint32_t residual_samples,
 uint32_t predictor_order,
 uint32_t min_partition_order,
 uint32_t max_partition_order
)
{
 int partition_order;
 uint32_t from_partition, to_partition = 0;
 const uint32_t blocksize = residual_samples + predictor_order;


 for(partition_order = (int)max_partition_order; partition_order >= 0; partition_order--) {
  FLAC__int32 r;
  FLAC__uint32 rmax;
  uint32_t partition, partition_sample, partition_samples, residual_sample;
  const uint32_t partitions = 1u << partition_order;
  const uint32_t default_partition_samples = blocksize >> partition_order;

                                                           ;

  for(partition = residual_sample = 0; partition < partitions; partition++) {
   partition_samples = default_partition_samples;
   if(partition == 0)
    partition_samples -= predictor_order;
   rmax = 0;
   for(partition_sample = 0; partition_sample < partition_samples; partition_sample++) {
    r = residual[residual_sample++];

    if(r < 0)
     rmax |= ~r;
    else
     rmax |= r;
   }

   raw_bits_per_partition[partition] = rmax? FLAC__bitmath_ilog2(rmax) + 2 : 1;
  }
  to_partition = partitions;
  break;
 }


 for(from_partition = 0, --partition_order; partition_order >= (int)min_partition_order; partition_order--) {
  uint32_t m;
  uint32_t i;
  const uint32_t partitions = 1u << partition_order;
  for(i = 0; i < partitions; i++) {
   m = raw_bits_per_partition[from_partition];
   from_partition++;
   raw_bits_per_partition[to_partition] = ((m) >= (raw_bits_per_partition[from_partition]) ? (m) : (raw_bits_per_partition[from_partition]));
   from_partition++;
   to_partition++;
  }
 }
}
# 4365 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
static inline uint32_t count_rice_bits_in_partition_(
 const uint32_t rice_parameter,
 const uint32_t partition_samples,
 const FLAC__uint64 abs_residual_partition_sum
)
{
 return (uint32_t)(((FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN + (1+rice_parameter) * partition_samples + ( rice_parameter? (abs_residual_partition_sum >> (rice_parameter-1)) : (abs_residual_partition_sum << 1) ) - (partition_samples >> 1)) <= (4294967295U) ? (FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN + (1+rice_parameter) * partition_samples + ( rice_parameter? (abs_residual_partition_sum >> (rice_parameter-1)) : (abs_residual_partition_sum << 1) ) - (partition_samples >> 1)) : (4294967295U)));
# 4386 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 ;
}


FLAC__bool set_partitioned_rice_(



 const FLAC__uint64 abs_residual_partition_sums[],
 const uint32_t raw_bits_per_partition[],
 const uint32_t residual_samples,
 const uint32_t predictor_order,
 const uint32_t rice_parameter_limit,
 const uint32_t rice_parameter_search_dist,
 const uint32_t partition_order,
 const FLAC__bool search_for_escapes,
 FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents,
 uint32_t *bits
)
{
 uint32_t rice_parameter, partition_bits;
 uint32_t best_partition_bits, best_rice_parameter = 0;
 uint32_t bits_ = FLAC__ENTROPY_CODING_METHOD_TYPE_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN;
 uint32_t *parameters, *raw_bits;
 uint32_t partition, residual_sample;
 uint32_t partition_samples;
 const uint32_t partitions = 1u << partition_order;
 FLAC__uint64 mean, k;



 (void)rice_parameter_search_dist;


                                                                                                     ;

 parameters = partitioned_rice_contents->parameters;
 raw_bits = partitioned_rice_contents->raw_bits;

 for(partition = residual_sample = 0; partition < partitions; partition++) {
  partition_samples = (residual_samples+predictor_order) >> partition_order;
  if(partition == 0) {
   if(partition_samples <= predictor_order)
    return 0;
   else
    partition_samples -= predictor_order;
  }
  mean = abs_residual_partition_sums[partition];
# 4449 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
  if(mean <= 0x80000000/8) {

   FLAC__uint32 k2, mean2 = (FLAC__uint32) mean;
   rice_parameter = 0; k2 = partition_samples;
   while(k2*8 < mean2) {
    rice_parameter += 4; k2 <<= 4;
   }
   while(k2 < mean2) {
    rice_parameter++; k2 <<= 1;
   }
  }
  else {
   rice_parameter = 0; k = partition_samples;
   if(mean <= 0x8000000000000000ULL/128)
    while(k*128 < mean) {
     rice_parameter += 8; k <<= 8;
    }
   while(k < mean) {
    rice_parameter++; k <<= 1;
   }
  }

  if(rice_parameter >= rice_parameter_limit) {



   rice_parameter = rice_parameter_limit - 1;
  }

  best_partition_bits = 4294967295U;
# 4501 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
   partition_bits = count_rice_bits_in_partition_(rice_parameter, partition_samples, abs_residual_partition_sums[partition]);

   if(partition_bits < best_partition_bits) {
    best_rice_parameter = rice_parameter;
    best_partition_bits = partition_bits;
   }



  if(search_for_escapes) {
   partition_bits = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN + raw_bits_per_partition[partition] * partition_samples;
   if(partition_bits <= best_partition_bits && raw_bits_per_partition[partition] < 32) {
    raw_bits[partition] = raw_bits_per_partition[partition];
    best_rice_parameter = 0;
    best_partition_bits = partition_bits;
   }
   else
    raw_bits[partition] = 0;
  }
  parameters[partition] = best_rice_parameter;
  if(best_partition_bits < 4294967295U - bits_)
   bits_ += best_partition_bits;
  else
   bits_ = 4294967295U;
  residual_sample += partition_samples;
 }

 *bits = bits_;
 return 1;
}

uint32_t get_wasted_bits_(FLAC__int32 signal[], uint32_t samples)
{
 uint32_t i, shift;
 FLAC__int32 x = 0;

 for(i = 0; i < samples && !(x&1); i++)
  x |= signal[i];

 if(x == 0) {
  shift = 0;
 }
 else {
  for(shift = 0; !(x&1); shift++)
   x >>= 1;
 }

 if(shift > 0) {
  for(i = 0; i < samples; i++)
    signal[i] >>= shift;
 }

 return shift;
}

uint32_t get_wasted_bits_wide_(FLAC__int64 signal_wide[], FLAC__int32 signal[], uint32_t samples)
{
 uint32_t i, shift;
 FLAC__int64 x = 0;

 for(i = 0; i < samples && !(x&1); i++)
  x |= signal_wide[i];

 if(x == 0) {
  shift = 1;
 }
 else {
  for(shift = 0; !(x&1); shift++)
   x >>= 1;
 }

 if(shift > 0) {
  for(i = 0; i < samples; i++)
    signal[i] = (FLAC__int32)(signal_wide[i] >> shift);
 }

 return shift;
}


void append_to_verify_fifo_(verify_input_fifo *fifo, const FLAC__int32 * const input[], uint32_t input_offset, uint32_t channels, uint32_t wide_samples)
{
 uint32_t channel;

 for(channel = 0; channel < channels; channel++)
  memcpy(&fifo->data[channel][fifo->tail], &input[channel][input_offset], sizeof(FLAC__int32) * wide_samples);

 fifo->tail += wide_samples;

                                       ;
}

void append_to_verify_fifo_interleaved_(verify_input_fifo *fifo, const FLAC__int32 input[], uint32_t input_offset, uint32_t channels, uint32_t wide_samples)
{
 uint32_t channel;
 uint32_t sample, wide_sample;
 uint32_t tail = fifo->tail;

 sample = input_offset * channels;
 for(wide_sample = 0; wide_sample < wide_samples; wide_sample++) {
  for(channel = 0; channel < channels; channel++)
   fifo->data[channel][tail] = input[sample++];
  tail++;
 }
 fifo->tail = tail;

                                       ;
}

FLAC__StreamDecoderReadStatus verify_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
{
 FLAC__StreamEncoder *encoder = (FLAC__StreamEncoder*)client_data;
 const size_t encoded_bytes = encoder->private_->verify.output.bytes;
 (void)decoder;

 if(encoder->private_->verify.needs_magic_hack) {
                                                  ;
  *bytes = (4u);
  memcpy(buffer, FLAC__STREAM_SYNC_STRING, *bytes);
  encoder->private_->verify.needs_magic_hack = 0;
 }
 else {
  if(encoded_bytes == 0) {




                  ;
   return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
  }
  else if(encoded_bytes < *bytes)
   *bytes = encoded_bytes;
  memcpy(buffer, encoder->private_->verify.output.data, *bytes);
  encoder->private_->verify.output.data += *bytes;
  encoder->private_->verify.output.bytes -= *bytes;
 }

 return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
}

FLAC__StreamDecoderWriteStatus verify_write_callback_(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data)
{
 FLAC__StreamEncoder *encoder = (FLAC__StreamEncoder *)client_data;
 uint32_t channel;
 const uint32_t channels = frame->header.channels;
 const uint32_t blocksize = frame->header.blocksize;
 const uint32_t bytes_per_block = sizeof(FLAC__int32) * blocksize;

 (void)decoder;

 if(encoder->protected_->state == FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR) {

  return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
 }

 for(channel = 0; channel < channels; channel++) {
  if(0 != memcmp(buffer[channel], encoder->private_->verify.input_fifo.data[channel], bytes_per_block)) {
   uint32_t i, sample = 0;
   FLAC__int32 expect = 0, got = 0;

   for(i = 0; i < blocksize; i++) {
    if(buffer[channel][i] != encoder->private_->verify.input_fifo.data[channel][i]) {
     sample = i;
     expect = (FLAC__int32)encoder->private_->verify.input_fifo.data[channel][i];
     got = (FLAC__int32)buffer[channel][i];
     break;
    }
   }
                              ;
                                                                                   ;
   encoder->private_->verify.error_stats.absolute_sample = frame->header.number.sample_number + sample;
   encoder->private_->verify.error_stats.frame_number = (uint32_t)(frame->header.number.sample_number / blocksize);
   encoder->private_->verify.error_stats.channel = channel;
   encoder->private_->verify.error_stats.sample = sample;
   encoder->private_->verify.error_stats.expected = expect;
   encoder->private_->verify.error_stats.got = got;
   encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA;
   return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
  }
 }

 encoder->private_->verify.input_fifo.tail -= blocksize;
                                                                     ;
 for(channel = 0; channel < channels; channel++)
  memmove(&encoder->private_->verify.input_fifo.data[channel][0], &encoder->private_->verify.input_fifo.data[channel][blocksize], encoder->private_->verify.input_fifo.tail * sizeof(encoder->private_->verify.input_fifo.data[0][0]));
 return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
}

void verify_metadata_callback_(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data)
{
 (void)decoder, (void)metadata, (void)client_data;
}

void verify_error_callback_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data)
{
 FLAC__StreamEncoder *encoder = (FLAC__StreamEncoder*)client_data;
 (void)decoder, (void)status;
 encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
}

FLAC__StreamEncoderReadStatus file_read_callback_(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
{
 (void)client_data;

 *bytes = fread(buffer, 1, *bytes, encoder->private_->file);
 if (*bytes == 0) {
  if ((((encoder->private_->file)->_flags & 0x0020) != 0))
   return FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM;
  else if ((((encoder->private_->file)->_flags & 0x0040) != 0))
   return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;
 }
 return FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE;
}

FLAC__StreamEncoderSeekStatus file_seek_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)
{
 (void)client_data;

 if(fseeko(encoder->private_->file, (off_t)absolute_byte_offset, 0) < 0)
  return FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR;
 else
  return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;
}

FLAC__StreamEncoderTellStatus file_tell_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
{
 off_t offset;

 (void)client_data;

 offset = ftello(encoder->private_->file);

 if(offset < 0) {
  return FLAC__STREAM_ENCODER_TELL_STATUS_ERROR;
 }
 else {
  *absolute_byte_offset = (FLAC__uint64)offset;
  return FLAC__STREAM_ENCODER_TELL_STATUS_OK;
 }
}
# 4754 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
FLAC__StreamEncoderWriteStatus file_write_callback_(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, uint32_t samples, uint32_t current_frame, void *client_data)
{
 (void)client_data, (void)current_frame;

 if(fwrite(buffer, sizeof(FLAC__byte), bytes, encoder->private_->file) == bytes) {
  FLAC__bool call_it = 0 != encoder->private_->progress_callback && (
# 4769 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
   samples > 0
  );
  if(call_it) {





   encoder->private_->progress_callback(encoder, encoder->private_->bytes_written+bytes, encoder->private_->samples_written+samples, encoder->private_->frames_written+(samples?1:0), encoder->private_->total_frames_estimate, encoder->private_->client_data);
  }
  return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
 }
 else
  return FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;
}




FILE *get_binary_stdout_(void)
{
# 4800 "C:/Users/takaaki/git/sw_xSSDAC/module_libFLAC/source/stream_encoder.c"
 return (__getstdout());
}
